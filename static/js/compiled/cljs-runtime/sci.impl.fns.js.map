{"version":3,"sources":["sci/impl/fns.cljc"],"mappings":"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","names":["sci.impl.fns/throw-arity","fn-name","macro?","args","js/Error","actual-count","cljs.core/count","cljs.core/PROTOCOL_SENTINEL","this__4369__auto__","writer__4370__auto__","opt__4371__auto__","cljs.core/-write","sci.impl.fns/Recur","sci.impl.fns/->Recur","val","this","p__97322","map__97323","cljs.core.apply","cljs.core/hash-map","cljs.core.get","sci.impl.fns/parse-fn-args+body","ctx","interpret","eval-do*","fixed-arity","var-arg-name","params","body","_m","with-meta?","min-var-args-arity","f","bindings","cljs.core/seq","ret","fp","cljs.core/first","cljs.core._EQ_","cljs.core.assoc","cljs.core/second","cljs.core/next","G__97330","G__97331","recur?","recur-val","sci.impl.types/getVal","vec__97332","cljs.core.nth","vec__97335","fixed-args","rest-args","cljs.core.subvec","cljs.core.into","cljs.core/with-meta","sci.impl.fns/lookup-by-arity","arities","arity","cljs.core/some","map__97338","cljs.core/meta","or__4126__auto__","and__4115__auto__","p__97344","map__97345","sci.impl.fns/eval-fn","fn-bodies","self-ref","cljs.core.atom","call-self","cljs.core/deref","cljs.core/assoc-in","single-arity?","p1__97341#","cljs.core.map","arg-count","temp__5733__auto__","p1__97342#","cljs.core.vary_meta","cljs.core/reset!"],"sourcesContent":["(ns sci.impl.fns\n  {:no-doc true}\n  (:require [sci.impl.types :as t]))\n\n(defn throw-arity [fn-name macro? args]\n  (throw (new #?(:clj Exception\n                 :cljs js/Error)\n              (let [actual-count (if macro? (- (count args) 2)\n                                     (count args))]\n                (str \"Cannot call \" fn-name \" with \" actual-count \" arguments\")))))\n\n(deftype Recur #?(:clj [val]\n                  :cljs [val])\n  t/IBox\n  (getVal [this] val))\n\n(defn parse-fn-args+body\n  [ctx interpret eval-do*\n   {:sci.impl/keys [fixed-arity var-arg-name params body] :as _m}\n   fn-name macro? with-meta?]\n  (let [min-var-args-arity (when var-arg-name fixed-arity)\n        f (fn run-fn [& args]\n            (let [;; tried making bindings a transient, but saw no perf improvement (see #246)\n                  bindings (:bindings ctx)\n                  bindings\n                  (loop [args (seq args)\n                         params (seq params)\n                         ret bindings]\n                    (if params\n                      (let [fp (first params)]\n                        (if (= '& fp)\n                          (assoc ret (second params) args)\n                          (do\n                            (when-not args\n                              (throw-arity fn-name macro? args))\n                            (recur (next args) (next params)\n                                   (assoc ret fp (first args))))))\n                      (do\n                        (when args\n                          (throw-arity fn-name macro? args))\n                        ret)))\n                  ctx (assoc ctx :bindings bindings)\n                  ret (if (= 1 (count body))\n                        (interpret ctx (first body))\n                        (eval-do* ctx body))\n                  ;; m (meta ret)\n                  recur? (instance? Recur ret)]\n              (if recur?\n                (let [recur-val (t/getVal ret)]\n                  (if min-var-args-arity\n                    (let [[fixed-args [rest-args]]\n                          [(subvec recur-val 0 min-var-args-arity)\n                           (subvec recur-val min-var-args-arity)]]\n                      (recur (into fixed-args rest-args)))\n                    (recur recur-val)))\n                ret)))]\n    (if with-meta?\n      (with-meta\n        f\n        (if min-var-args-arity\n          {:sci.impl/min-var-args-arity min-var-args-arity}\n          {:sci.impl/fixed-arity fixed-arity}))\n      f)))\n\n(defn lookup-by-arity [arities arity]\n  (some (fn [f]\n          (let [{:sci.impl/keys [fixed-arity min-var-args-arity]} (meta f)]\n            (when (or (= arity fixed-arity )\n                      (and min-var-args-arity\n                           (>= arity min-var-args-arity)))\n              f))) arities))\n\n(defn eval-fn [ctx interpret eval-do* {:sci.impl/keys [fn-bodies fn-name] :as f}]\n  (let [macro? (:sci/macro f)\n        self-ref (atom nil)\n        call-self (fn [& args]\n                    (apply @self-ref args))\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] call-self)\n                ctx)\n        single-arity? (= 1 (count fn-bodies))\n        f (if single-arity?\n            (parse-fn-args+body ctx interpret eval-do* (first fn-bodies) fn-name macro? false)\n            (let [arities (map #(parse-fn-args+body ctx interpret eval-do* % fn-name macro? true) fn-bodies)]\n              (fn [& args]\n                (let [arg-count (count args)]\n                  (if-let [f (lookup-by-arity arities arg-count)]\n                    (apply f args)\n                    (throw (new #?(:clj Exception\n                                   :cljs js/Error)\n                                (let [actual-count (if macro? (- arg-count 2)\n                                                       arg-count)]\n                                  (str \"Cannot call \" fn-name \" with \" actual-count \" arguments\")))))))))\n        f (if macro?\n            (vary-meta\n             f\n             #(assoc % :sci/macro macro?))\n            f)]\n    (reset! self-ref f)\n    f))\n\n;;;; Scratch\n\n(comment\n  )\n"]}