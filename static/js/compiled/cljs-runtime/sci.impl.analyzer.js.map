{"version":3,"sources":["sci/impl/analyzer.cljc"],"mappings":";AAkBA,AAAA,AAAA,AAAKA;AAIL,AAAA,AAAA,AAAKC;AAKL,AAAA,AAAAC,AAAMQ,AAA0CC,AAAUC;AAA1D,AAAA,AAAAT,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAAI,AAAA,AAAAC,AAAAL,AAAA;AAAAM,AAAA,AAAAD,AAAAL,AAAA;AAAA,AACE,AAAU,AAAAU,AAAA;AAAAC,AAAsB,AAAA,AAAA,AAAIF,AAAII;AAA9B,AAAA,AAAAH,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;;AAAX;;AAAA,AACE,AAAMJ,AAAU,AAACM,AAAcN;AAA/B,AACE,AAAU,AAAA,AAAIJ,AAAM,AAACW,AAAUX,AAAMI;AAArC;AAAA,AAEE,AAACQ,AAA0B,AAAA,AAAKP,AAAwBA;;;AAC1D,AAAM,AAAA,AAAIH,AAAK,AAACS,AAAUT,AAAKE;AAA/B,AAEE,AAACQ,AAA0B,AAAA,AAAKP,AAAwBA;;AAF1D;;;;AAIN,AAAA,AAAAQ,AAAMG,AAAgCX,AAAIa;AAA1C,AAAA,AAAAJ,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAjB,AAAA,AAAAiB,AAAA,AAAA,AAAA,AAAA,AAAAhB,AAAAC,AAAAe,AAAAA;AAAAA,AAAiCG;AAAjCF,AAAA,AAAAd,AAAAa,AAAA;AAAA,AACE,AAAMM,AAAO,AAAAC,AAAQ,AAACC,AAAUjB;AAAnB,AAAA,AAAA,AAAAgB,AAAA;AAAA;;AAAA,AAAAA,AAAwBE;;;AAC/BC,AAAS,AAACD,AAAO,AAACE,AAAKpB;AAD7B,AAAAc,AAEMJ,AAAKA;AACLW,AAAI,AAACC;AACLC,AAAe,AAAAC,AAAA,AAAA,AAAId;AAAJ,AAAA,AAAAc,AAAAA,AAAoBH,AAAAA,AAAAA;;AAEnCN,AAAO,AAAA,AAAMA,AAAO,AAAAU,AAAI,AAAA,AAAA,AAACC,AAAOH,AAAyBR;AAArC,AAAA,AAAAU;AAAAA;;AACIV;;AADjB;AANb,AAQE,AAAAU,AAAI,AAACE,AAAKJ,AAAevB;AAAzB,AAAA,AAAAyB;AAAAA;;AACI,AACE,AAAAG,AAAKb;AAAL,AAAA,AAAAa;AAAY,AAAI,AAAA,AAAA,AAACC,AAAEd,AAAsB,AAAA,AAAA,AAACc,AAAEd;;AAA5Ca;;;AACA,AAAAH,AAAI,AAAAK,AAAQpB;AAARoB,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAAA;AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAwB,AAAAA,AAAA,AAAA,AAAClC;AAAzB,AAAA,AAAA,AAAAkC,AAAA;AAAA;;AAA4C,AAAAA,AAACH,AAAKR;;;AAAtD,AAAA,AAAAM;AAAAA;;AACI,AAAAM,AAAa,AAAA,AAAA,AAAMlB,AAAM,AAACjB,AAAIP,AAAO8B;AAArC,AAAA,AAAAY;AAAA,AAAA,AAAAA,AAAWC;AAAX,AAAA,AACGhC,AAAIgC;;AADP;;;;AAHN,AAKEjB;AACA,AAAAU,AAAI,AAAAQ,AAAQvB;AAARuB,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAAA;AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAAA,AAAwBlB,AAAAA,AAAAA;AAAxB,AAAA,AAAA,AAAAkB,AAAA;AAAA;;AAA+B,AAAAA,AAACN,AAAKR;;;AAAzC,AAAA,AAAAM;AAAAA;;AACI,AAAAM,AAAiB,AAACI,AAAsBvB,AAAIG;AAA5C,AAAA,AAAAgB;AAAA,AAAA,AAAAA,AAAWG;AAAX,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACGlC,AAAoCkC,AAAMf;;AAD7C;;;;AAPN,AAWE,AAAU,AAACb,AACA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACoB,AAAOH,AAAgDJ;AADnE;;AAAA,AAEE,AAAAM,AACC,AAAAW,AAAQ1B;AAAR0B,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAAA;AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAwB,AAAAA,AAAA,AAAA,AAACxC;AAAzB,AAAA,AAAA,AAAAwC,AAAA;AAAA;;AAA4C,AAAAA,AAACT,AAAKR;;;AADnD,AAAA,AAAAM;AAAAA;;AAAA,AAAAA,AAEC,AAAA,AAAA,AAAA,AAAM,AAAA,AAAA,AAAMZ,AAAM,AAACjB,AAAIP,AAAOW,AAC3BA,AAAIA;AAHR,AAAA,AAAAyB;AAAAA;;AAIC,AAAAM,AAAa,AAACI,AAAsBvB,AAAIZ;AAAxC,AAAA,AAAA+B;AAAA,AAAA,AAAAA,AAAWM;AAAX,AAAA,AACGrC,AAAIqC;;AADP;;;;;;;;;;AAGb,AAAA,AAAMC,AAAKC,AAAKC;AAAhB,AACE,AAAAT,AAAa,AAAC3B,AAAKoC;AAAnB,AAAA,AAAAT;AAAA,AAAA,AAAAA,AAAWU;AAAX,AACE,AAAA,AAAMA;;AADR;;;AAGF,AAAA,AAAAC,AAAMG,AAAoC7C,AAAIa;AAA9C,AAAA,AAAA8B,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAnD,AAAA,AAAAmD,AAAA,AAAA,AAAA,AAAA,AAAAlD,AAAAC,AAAAiD,AAAAA;AAAAA,AAAqC/B;AAArCgC,AAAA,AAAAhD,AAAA+C,AAAA;AAAA,AACE,AAAAG,AACM,AAAArB,AAEC,AAAAM,AACW,AAACJ,AAAKiB,AAAS5C;AAD1B,AAAA,AAAA+B;AAAA,AAAA,AAAAmB,AAAAnB;AAAA,AAAAgB,AAAAG,AAAA,AAAA,AAAYF;AAAZ,AAAAD,AAAAG,AAAA,AAAA,AAAclB;AAAd,AAGE,AAAMmB,AAAE,AAACb,AAAI1B,AAAIoB;AACXA,AAAE,AAACoB,AAAiBJ;AAEpBhB,AAAE,AAAImB,AAAE,AAAA,AAACE,AAAUrB,AACAsB,AAAWH,AACxBnB;AALZ,AAAA,AAMGgB,AAAEhB;;AATP;;;AAFD,AAAA,AAAAP;AAAAA;;AAYC,AAAAM,AAGM,AAACpB,AAAQC,AAAIZ,AAAIa;AAHvB,AAAA,AAAAkB;AAAA,AAAA,AAAAwB,AAAAxB;AAAA,AAAAgB,AAAAQ,AAAA,AAAA,AACMP;AADN,AAAAD,AAAAQ,AAAA,AAAA,AACQC;AADRD,AACcN;AADd,AAME,AAACnD,AAAkBc,AAAIoC,AAAEhD;;AACzBiD;;AAPF;;;;AAbP,AAAAF,AAAAD,AAAA,AAAA,AAAOE;AAAP,AAAAD,AAAAD,AAAA,AAAA,AAASd;AAATc,AAAeG;AAAf,AAsBE,AAAAQ,AAAW,AAAA,AAAK,AAACC,AAAI,AAAA,AAAyB9C,AAC9B,AAACR,AAAK4C;AADtB,AAAA,AAAAS;AAAA,AAAAA,AAAShB;AAAT,AAEE,AAAI,AAAA,AAAkBA;AAAtB,AAGGO,AAAE,AAAA,AAAA,AAAA,AAAA,AAACW,AAAW3B;;AAEfiB;;;AACFA;;;AAEN,AAAA,AAAA,AAAAW,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AACFlD,AAAIZ;AADR,AACa,AAAA,AAACgE,AAAepD,AAAIZ;;;AADjC,AAAA,AAAA,AAAM8D,AAEFlD,AAAIZ,AAAIa;AAFZ,AAGG,AAAMb,AAAIA;AACJiE,AAAI,AAACC,AACA,AAAAzC,AACC,AAACoB,AAAOjC,AAAIZ,AAAIa;AADjB,AAAA,AAAAY;AAAAA;;AAIC,AAAM0C,AAAE,AAAC/C,AAAKpB;AAAd,AACE,AACE,AAAA4B,AAAKf;AAAL,AAAA,AAAAe;AAAA,AACK,AAAA,AAACwC,AAAiBD,AAClB,AAAA,AAAG,AAAOA;;AAFfvC;;;AADF,AAAA,AAAA,AAIG5B;;AAJH,AAKE,AAAA4B,AAAKf;AAAL,AAAA,AAAAe;AAAA,AACK,AAAA,AAACyC,AAAeF,AAChB,AAAA,AAAG,AAAOA;;AAFfvC;;;AALF,AAAA,AAAA,AAQG5B;;AARH,AASE,AAAA,AAACoE,AAAiBD;AAClB,AAAMnC,AAAE,AAACd,AAAO,AAAA,AAACoD,AAAKH;AAAtB,AAAA,AACGnC,AAAEA;;AAXP,AAYQ,AAACzB,AACA,AAAA,AAAkC,AAAKP,AACvCA;;;;;;;AArBvB,AAuBEiE;;;AA1BL,AAAA,AAAA,AAAMH;;AAAN,AA4BA,AAAA,AAEA,AAAA,AAAMS,AAAkB3D,AAAI4D;AAA5B,AACE,AAAA,AAAAC,AAACC;AAAD,AAAO,AAAAD,AAAAA,AAACE,AAAAA,AAAAA,AAAQ/D,AAAAA;AAAO4D;;AAEzB,AAAA,AAAMI,AACHC,AAAOC;AADV,AAEE,AAAI,AAACC,AAAOC,AAAQH;AAApB,AAAA,AAAA,AACWA,AACFC;;AACP,AAAOD,AAAOA;AACPI,AAAW,AAAA,AAACtB,AAAa,AAACvD,AAAKyE;AADtC,AAEOK;;AAFP,AAGE,AAAIL;AACF,AAAI,AAAAU,AAAS,AAACC,AAAMX;AAClB,AAAO,AAACY,AAAKZ;AAAQ,AAACa,AAAKT,AAAW,AAACO,AAAMX;AAASK;;;;;;AACtD,AAAMS,AAAO,AAAA,AAACC;AAAd,AACE,AAAO,AAACH,AAAKZ;AAAQ,AAACa,AAAKT,AAAWU;AAC3BT,AAAK,AAACQ,AAAK,AAACF,AAAMX,AAAS,AAACa,AAAKC;;;;;;;AALlD,AAAA,AAAA,AAAA,AAAA,AAAAR,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAMWL,AACMC,AACFJ;;;;;;AAErB,AAAA,AAAAe,AAAAC,AAAMM,AAAgDC,AAAsCG;AAA5F,AAAA,AAAAT,AAAAF;AAAAE,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAvG,AAAA,AAAAuG,AAAA,AAAA,AAAA,AAAA,AAAAtG,AAAAC,AAAAqG,AAAAA;AAAAA,AAAiDnF;AAAjDoF,AAAA,AAAApG,AAAAmG,AAAA;AAAAE,AAAAH;AAAAI,AAAA,AAAAd,AAAAa;AAAAE,AAAA,AAAAX,AAAAU;AAAAA,AAAA,AAAAT,AAAAS;AAAAC,AAA+DG;AAA/DJ,AAAgFK;AAAhF,AACE,AAAUD;AAAV;AAAA,AACE,AAAA,AAAC/F,AAA2DyF;;;AAC9D,AAAU,AAACS,AAAQH;AAAnB;AAAA,AACE,AAAA,AAAC/F,AAAqEyF;;;AACxE,AAAMM,AAAe,AAAIE,AAAO,AAAA,AAAA,AAAA,AAAA,AAAA,AAACG,AAAoBL,AAC5BA;AACnBM,AAAW,AAAA,AAAAC,AAACC;AAAD,AAAa,AAAA,AAAA,AAAAD,AAACE;AAAWT;AACpCU,AAAY,AAACC,AAAML;AACnBM,AAAa,AAAChD,AAAO,AAAA,AAAAiD,AAACC;AAAD,AAAa,AAAA,AAAA,AAAAD,AAACJ;AAAWT;AAC9Ce,AAAU,AAAC5B,AAAKc;AAChBe,AAAM,AAAA,AAAMD,AACJ,AAAME,AAAE,AAAC/B,AAAMe;AAAf,AACE,AAAM,AAACiB,AAAKD;AAAZ,AAAeA;;AAAf;;AAFJ;AAGNhB,AAAW,AAAIe,AAAMD,AAAUd;AAC/Be,AAAM,AAAA7F,AAAI6F;AAAJ,AAAA,AAAA7F;AAAAA;;AAAU,AAACrB,AAAKkG;;;AACtBmB,AAAI,AAAA,AAAMH;AACVI,AAAK,AAAA,AAAOJ;AACZf,AAAW,AAAA,AAAApB,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAqC,AAAA,AAAAxC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAIoC,AACW,AAAA,AAAAvC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAI,AAAA,AAAK,AAAC2B,AAAMV,AACPA,AACP,AAACf,AAAMe,AAChB,AAACqB,AAAI,AAAMvF;AAAN,AAAA,AAAA8C,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAmBjD;AAJhC,AAAAiD,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAIoCoC,AAElCnB;AACbA,AAAW,AAAIkB,AACF,AAACpC,AAAO,AAACuC,AAAI,AAAMvF;AAAN,AAAA,AAAA8C,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAmBjD;AAAIoF,AAC5BlB,AACRA;AAvBnBG,AAwB8B,AAAC9B,AAAmB0B,AAAeC;AAxBjEG,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAlH,AAAA,AAAAkH,AAAA,AAAA,AAAA,AAAA,AAAAjH,AAAAC,AAAAgH,AAAAA;AAAA7B,AAAA,AAAAjF,AAAA8G,AAAA;AAAA5B,AAAA,AAAAlF,AAAA8G,AAAA;AAyBM9F,AAAI,AAAA,AAACiH,AAAOjH,AAAckH,AAAM,AAACC,AAAOlD,AACA,AAAA,AAACmD;AACzClD,AAAK,AAACP,AAAiB3D,AAAIkE;AA3BjC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AA4BmBA,AACED,AACKmC,AACCE,AACLb;;AAExB,AAAA,AAAA4B,AAAMI,AAAWzH,AAAmC4F;AAApD,AAAA,AAAA0B,AAAAD;AAAAE,AAAA,AAAA/C,AAAA8C;AAAAE,AAAA,AAAA5C,AAAA2C;AAAAA,AAAA,AAAA1C,AAAA0C;AAAAC,AAAsBE;AAAtBF,AAAA,AAAA5C,AAAA2C;AAAAA,AAAA,AAAA1C,AAAA0C;AAAAC,AAA0BG;AAA1BJ,AAAkCrD;AAAlCoD,AAA2ClC;AAA3C,AACE,AAAMpF,AAAI,AAAA,AAAC4H,AAAM5H,AAAaoF;AACxBK,AAAQ,AAAA,AAAI,AAAAd,AAASgD,AACXA;AAEVzD,AAAK,AAAIuB,AACFvB,AACA,AAAC2D,AAAKF,AAAMzD;AAEnB4D,AAAO,AAAA,AAAI,AAACC,AAAK,AAACnD,AAAMV,AACfA,AACCA;AACVlE,AAAI,AAAIyF,AAAQ,AAAA,AAAA,AAAA,AAACuC,AAAShI,AAAeyF,AACjCzF;AACRiI,AAAgB,AAACC,AACA,AAAAC,AAA+CjE;AAA/C,AAAA,AAAAkE,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAxJ,AAAA,AAAAwJ,AAAA,AAAA,AAAA,AAAA,AAAAvJ,AAAAC,AAAAsJ,AAAAA;AAAAA,AAA0CG;AAA1CF,AAAA,AAAArJ,AAAAoJ,AAAA;AAAAE,AAAA,AAAAtJ,AAAAoJ,AAAA;AAAA,AACE,AAAMI,AAAQ,AAAC5D,AAAMV;AACfA,AAAK,AAACsB,AAAoBxF,AAAIyF,AAAQvB,AAAK0B;AAC3C1B,AAAK,AAAA,AAAC0D,AAAM1D,AAAuBsE;AACnClC,AAAa,AAAA,AAAwBpC;AACrCkC,AAAY,AAAA,AAAuBlC;AACnCuE,AAAgB,AAAA,AAAA,AAAMnC,AAAaF;AALzC,AAME,AAAM,AAAApF,AAAKsF;AAAL,AAAA,AAAAtF;AAAkBsH;;AAAlBtH;;;AAAN,AACE,AAAA,AAACrB,AAAqEyF;;AADxE;;AAEA,AAAM,AAAA,AAAApE,AAAK,AAAC8B,AAAIwD,AAAcgC;AAAxB,AAAA,AAAAtH;AAAoC,AAAGoF,AAAYkC;;AAAnDtH;;AAAA;AAAN,AACE,AAAA,AAACrB,AAC0EyF;;AAF7E;;AAGImD,AACA,AAAA,AAAA,AAACX,AAAmBa,AACF,AAAAC,AAAK,AAAA,AAAuBxE,AAE9C,AAAC+C,AACD,AAACA;AAHiB0B,AACKN;AADL,AAAA,AAAAK,AAAAC,AAAAD,AAAAC;AAElB,AAAgBC,AAAK1E,AACrB,AAAkB0E,AAAKJ;AAlBhC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAsBiBV;AACjCe,AAAQ,AAAA,AAASZ;AACjBa,AAAS,AAAA,AAAWb;AArC1B,AAsCE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAClF,AAAgC8F,AACFpD,AACCqD;;AAIpC,AAAA,AAAMC,AACH/I,AAAIgJ,AAA0BC;AADjC,AAEE,AAAAC,AACM,AAAChB,AACA,AAAAkB,AAAAC;AAAA,AAAA,AAAAC,AAAAF;AAAA,AAAAjH,AAAAmH,AAAA,AAAA,AAAMtJ;AAAN,AAAAmC,AAAAmH,AAAA,AAAA,AAAUH;AAAVI,AAAAF;AAAA,AAAAlH,AAAAoH,AAAA,AAAA,AAA6BC;AAA7B,AAAArH,AAAAoH,AAAA,AAAA,AAA0CE;AAA1C,AACE,AAAMrI,AAAE,AAAC2C,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIyJ,AAAAA;AAArB,AAAA,AACG,AAAA,AAACxC,AAAOjH,AAAc0C,AAAM8G,AAAapI,AACzC,AAAC0D,AAAKqE,AAAiBK,AAAapI;AAJ1C,AAAA,AAKEpB,AACD,AAAA,AAAC0J,AAAYV;AAPpB,AAAA7G,AAAA+G,AAAA,AAAA,AAAOlJ;AAAP,AAAAmC,AAAA+G,AAAA,AAAA,AAAWC;AAAX,AAQE,AAAA,AAAA5E,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAACiF,AAAwBR,AAAmB,AAACxF,AAAiB3D,AAAIiJ;;AAEtE;;;AAAA,AAAAW,AAAMI,AAEHhK;AAFH,AAAA,AAAA6J,AAAAD;AAAAE,AAAA,AAAAtF,AAAAqF;AAAAE,AAAA,AAAAnF,AAAAkF;AAAAA,AAAA,AAAAjF,AAAAiF;AAAAC,AAEQE;AAFRF,AAAA,AAAAnF,AAAAkF;AAAAA,AAAA,AAAAjF,AAAAiF;AAAAC,AAEaG;AAFbJ,AAE6Bb;AAF7B,AAGE,AAAMiB,AAAa,AAACC,AAAYD;AAAhC,AACE,AAACnB,AAAY/I,AAAIkK,AAAajB;;AAElC;;;AAAA,AAAAmB,AAAMI,AAEHxK;AAFH,AAAA,AAAAqK,AAAAD;AAAAE,AAAA,AAAA9F,AAAA6F;AAAAE,AAAA,AAAA3F,AAAA0F;AAAAA,AAAA,AAAAzF,AAAAyF;AAAAC,AAEQE;AAFRH,AAEYI;AAFZ,AAGE,AAAMC,AACA,AAAOF,AAAEA;AAAGC,AAAMA;;AAAlB,AACE,AAAIA;AACF,AAAME,AAAK,AAAChG,AAAM8F;AACZG,AAAS,AAAI,AAAC9C,AAAK6C,AACR,AAAC7H,AAAU,AAAC0B,AAAO,AAAAC,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAM,AAACE,AAAMgG,AAAMH,AACnB,AAAC5F,AAAK+F,AACvB,AAACpL,AAAKoL,AACR,AAAAlG,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAMkG,AAAKH;AAL5B,AAME,AAAOI;AAAS,AAAChG,AAAK6F;;;;;AAASD;;;;;AAT3C,AAUE,AAAC1G,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAI2K,AAAAA;;AAEjB;;;AAAA,AAAAG,AAAMI,AAEHlL;AAFH,AAAA,AAAA+K,AAAAD;AAAAE,AAAA,AAAAxG,AAAAuG;AAAAE,AAAA,AAAArG,AAAAoG;AAAAA,AAAA,AAAAnG,AAAAmG;AAAAC,AAEQE;AAFRF,AAAA,AAAArG,AAAAoG;AAAAA,AAAA,AAAAnG,AAAAmG;AAAAC,AAEYrJ;AAFZqJ,AAAA,AAAArG,AAAAoG;AAAAA,AAAA,AAAAnG,AAAAmG;AAAAC,AAEiBG;AAFjBJ,AAEwBN;AAFxB,AAGE,AAAAW,AAAA,AAAA9G,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAAqC,AAAA,AAAAxC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAgC0G,AAAMxJ,AACL,AAAC4J,AAAW,AAACpE,AAAOgE,AAAM,AAACK,AAAQf,AACrC,AAAI,AAACgB,AAAOhB,AACVU,AACA,AAACO,AAAKjB;AAJvCY,AAAA,AAAA9G,AAAA6G;AAAAE,AAAA,AAAA3G,AAAA0G;AAAAA,AAAA,AAAAzG,AAAAyG;AAAAC,AAAOrB;AAAPoB,AAAsBpH;AAAtB,AAKE,AAAC6E,AAAY/I,AAAIkK,AAAahG;;AAElC,AAAA,AAEA,AAAA,AAAA0H,AAAME,AACH9L;AADH,AAAA,AAAA6L,AAAAD;AAAA,AAAAzJ,AAAA0J,AAAA,AAAA,AACQE;AADR,AAAA5J,AAAA0J,AAAA,AAAA,AACaG;AADb,AAAA7J,AAAA0J,AAAA,AAAA,AACsBI;AADtB,AAAA9J,AAAA0J,AAAA,AAAA,AACiCK;AADjCL,AAC2CjK;AAD3C,AAEE,AAAAuK,AAAgBnM;AAAhBoM,AAAA,AAAA,AAAyBJ;AAAzB,AAAA,AAAAG,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;;AACD,AAAU,AAACC,AAAeN;AAA1B;AAAA,AACE,AAAA,AAACrM,AAA8DiC;;;AACjE,AAAM2K,AAAU,AAAA,AAAA,AAAML,AAAMD;AACtBO,AAAK,AAAID,AAAUL,AAAMD;AACzBO,AAAK,AAAA,AAAI,AAAA,AAACvL,AAAE,AAACoF,AAAMzE,AAEZ,AAACmC,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIwM,AAAAA;AACpB3K,AAAE,AAACrC,AAAKwM;AACRnK,AAAE,AAACkC,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAI6B,AAAAA;AACfA,AAAE,AAAA,AAAA,AAAA3B,AAAC0H,AAAM/F,AAAO4K;AAChB5K,AAAE,AAAI0K,AAAU,AAAA,AAAC3E,AAAM/F,AAAO0K,AAAW1K;AACzCmK,AAAS,AAACjJ,AAAUiJ,AAASnK;AATnC,AAUE,AAAA6K,AAAgB1M;AAAhB2M,AAAA,AAAA,AAAyBX;AAAzB,AAAA,AAAAU,AAAAC,AAAAD,AAAAC,AAACN,AAAAA,AAAAA;;AACD,AAAC1C,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAWsH,AAASQ;;AAExC,AAAA,AAAAI,AAAMI,AAAahN;AAAnB,AAAA,AAAA6M,AAAAD;AAAAE,AAAA,AAAAtI,AAAAqI;AAAAE,AAAA,AAAAnI,AAAAkI;AAAAA,AAAA,AAAAjI,AAAAiI;AAAAC,AAAwBE;AAAxBF,AAAA,AAAAnI,AAAAkI;AAAAA,AAAA,AAAAjI,AAAAiI;AAAAC,AAA2BtH;AAA3BqH,AAAqC5I;AAArC2I,AAA8CjL;AAA9C,AACE,AAAU,AAAC0K,AAAe7G;AAA1B;AAAA,AACE,AAAA,AAAC9F,AAA8DiC;;;AACjE,AAAAsL,AAAgBlN;AAAhBmN,AAAA,AAAA,AAAyB1H;AAAzB,AAAA,AAAAyH,AAAAC,AAAAD,AAAAC,AAACd,AAAAA,AAAAA;;AACD,AAAMzG,AAAO,AAAA,AAAC3E,AAAa,AAACT,AAAKyM;AAAjCG,AACsB,AAACE,AAAW,AAACC,AAAKzK,AAAI0K,AAAatJ;AADzD,AAAA/B,AAAAiL,AAAA,AAAA,AACOC;AADP,AAAAlL,AAAAiL,AAAA,AAAA,AACgBlJ;AACVtB,AAAE,AAAA,AAAA,AAAM,AAAC8I,AAAOxH,AACZ,AAAA,AAACvE,AAA2DiC;AAChE2K,AAAU,AAAApL,AAAc,AAACyD,AAAMyI;AAArB,AAAA,AAAAlM;AAAA,AAAA,AAAAA,AAAWsM;AAAX,AACE,AAAM,AAASA;AAAf,AAAmBA;;AAAnB;;;AADF;;;AAEVC,AAAS,AAAAvM,AAAa,AAACwK,AAAK0B;AAAnB,AAAA,AAAAlM;AAAA,AAAA,AAAAA,AAAWU;AAAX,AACE,AAAM,AAAC+E,AAAK/E;AAAZ,AAAeA;;AAAf;;;AADF;;;AAET6L,AAAS,AAAAC,AAAS3N;AAAT4N,AAAa,AAACC,AAAM,AAACrO,AAAKoC,AAAM8L;AAAhC,AAAA,AAAAC,AAAAC,AAAAD,AAAAC,AAAC7J,AAAAA,AAAAA;;AACV+J,AAAQ,AAAC/K,AAAU,AAAA,AAAA,AAAC8E,AAAS3D,AACnB,AAAC1E,AAAKoC;AAChBmM,AAAE,AAACtG,AAAUzH,AAAI8N,AAAQlI;AACzBkD,AAAS,AAACtE,AAAI,AAAA,AAAoBuJ;AAClCL,AAAS,AAAA,AAAA,AAAAxN,AAAA,AAAC0H,AAAM8F,AACKjB,AACK3D;AAC1BrD,AAAQ,AAAC1C,AAAU0C,AACT,AAAAuI,AAAQN;AAARM,AAAA,AAAAA,AACEzB,AAAU,AAAAyB,AAAA,AAACpG,AAAW2E;AADxB,AAAA,AAEE3G;AAAO,AAAAoI,AAAA,AAAA,AAACpG;;AAFVoG;;;AAGVD,AAAE,AAAA,AAAA,AAACnG,AAAMmG,AACWnI,AACOH;AAtBjC,AAuBE,AAACkE,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAWe,AAAQsI;;AAEvC,AAAA;;;AAAA,AAAA/K,AAAMsL;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAEH3M,AAAO+M;AAFV,AAAA;;;AAAA,AAAA,AAAA,AAAMJ;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA,AAAA5J,AAAA2J;AAAAA,AAAA,AAAA1J,AAAA0J;AAAA,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAAD,AAAAD;;;AAAA,AAIA,AAAA,AAAMI,AACH3O,AAAI4B;AADP,AAEE,AAAMiN,AAAG,AAACvL,AAAO1B;AACXkN,AAAU,AAAA,AAACC,AAAWF;AACtBG,AAAU,AAAA,AAACD,AAAW,AAACE,AAAKJ;AAFlCD,AAGgB,AAAA,AAAI,AAACzK,AAAOC,AAAQ0K,AACjBD,AAAGC,AACJ,AAAMI,AAAK,AAAA,AAACC,AAAW,AAAC9I,AAAMyI;AAAnB,AAA+B,AAAC9J;;AACrCoK,AAAI,AAACpI,AAAIqI,AAAOH,AAAKF;AACrBM,AAAK,AAACtI,AAAIqI,AAAOP,AAAUI;AAFjC,AAAA,AAGG,AAAA,AAACnJ,AAAQwJ,AAAI,AAAC/D,AAAW4D,AAAIE,AAAMJ;;AARxD,AAAA/M,AAAAyM,AAAA,AAAA,AAGOC;AAHP,AAAA1M,AAAAyM,AAAA,AAAA,AAGUM;AAMJhL,AAAK,AAACsL,AAAM5N;AACZ6N,AAAU,AAAA/K,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAWmK,AACL,AAAA,AAAAtK,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAACgL,AAAY,AAAC3I,AAAI+H,AAAa5K,AACxBgL;AAZ7B,AAaE,AAACnL,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIyP,AAAAA;;AAEjB,AAAA,AAAME,AACH3P,AAAI4B;AADP,AAEE,AAAMsC,AAAK,AAAC+K,AAAKrN;AAAjB,AACE,AAAC+H,AACA,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AACM,AAAAkL,AAAS5P;AAAT6P,AAES,AAAAnL,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAa,AAAA,AAAA,AAACmD,AAAS3D;AAFhC,AAAA,AAAA0L,AAAAC,AAAAD,AAAAC,AAAC9L,AAAAA,AAAAA;AADP,AAAA,AAAA,AAAA,AAAA;;AAKL,AAAA,AAAA+L,AAAMI,AACHlQ;AADH,AAAA,AAAA+P,AAAAD;AAAAE,AAAA,AAAAxL,AAAAuL;AAAAE,AAAA,AAAArL,AAAAoL;AAAAA,AAAA,AAAAnL,AAAAmL;AAAAC,AACQE;AADRH,AACc/G;AADd8G,AACwBnO;AADxB,AAEE,AAAAwO,AAAM,AAAC/J,AAAM4C;AAAb,AAAA,AAAAmH;AAAA;AAAA;AACQ,AAAA,AAACzQ,AAAoDiC;;;AAD7D;AAAA;AAEQ,AAAA,AAAA2C,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACiF,AAAwB,AAAChG,AAAiB3D,AAAIiJ;;;;AACrD,AAAA,AAACtJ,AAAqDiC;;;;AAE1D,AAAA,AAAMyO,AACHrQ,AAAI4B;AADP,AAEE,AAAMR,AAAE,AAAAkP,AAAStQ;AAATuQ,AAAa,AAACjN,AAAO1B;AAArB,AAAA,AAAA0O,AAAAC,AAAAD,AAAAC,AAACxM,AAAAA,AAAAA;;AACHyM,AAAQ,AAAChB,AAAM5N;AACf6O,AAAc,AAAA,AAAC1B,AAAWyB;AAC1BE,AAAe,AAAC/M,AAAiB3D,AAAI,AAAA,AAAC+O,AAAW,AAACE,AAAKuB;AACvDG,AAAQ,AAAA,AAAA,AAAA,AAAM,AAACC,AAAK,AAACvK,AAAMmK,AACX,AAAAK,AAAS7Q;AAAT8Q,AAAa,AAACnF,AAAK6E;AAAnB,AAAA,AAAAK,AAAAC,AAAAD,AAAAC,AAAC/M,AAAAA,AAAAA;AADT;AAERgN,AAAM,AAACvF,AAAWiF,AAAcC;AAChCM,AAAU,AAAKnP,AAAEO,AAAEhB;AAAT,AACE,AAAA,AAAQ,AAAC1B,AAAUmC,AAAEO;AACnB,AAACwF,AAAM/F,AAAEO,AAAEhB;;AACX,AAACzB,AAA0B,AAAA,AAAqCyC,AACrCR;;;AACzCqP,AAAS,AAAOF,AAAM,AAACvM,AAAIuM;AAAlB,AACOG;;AADP,AAEE,AAAIH;AACF,AAAAI,AAAoBJ;AAApBK,AAAA,AAAA5M,AAAA2M;AAAAE,AAAA,AAAAzM,AAAAwM;AAAAA,AAAA,AAAAvM,AAAAuM;AAAAC,AAAOjP;AAAPiP,AAAA,AAAAzM,AAAAwM;AAAAA,AAAA,AAAAvM,AAAAuM;AAAAC,AAASjQ;AAATgQ,AAAaL;AAAb,AACE,AAAI,AAACO,AAAMlP;AACT,AACC2O;AACA,AAAC7I,AAAO;AAAKK,AAAInG;AAAT,AACE,AAAC4O,AAAUzI,AAAInG,AAAEhB;;AACnB8P,AACA9O;;;;;AACT,AACC2O;AACA,AAACC,AAAUE,AAAQ9O,AAAEhB;;;;;;AAC1B8P;;;;;AACbK,AAAI,AAAC5H,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACiBuM,AACA7P,AACIuP,AACfA;AA/BhC,AAgCE,AAAChH,AAAe4H;;AAEpB,AAAA,AAAAC,AAAMI,AACH5R;AADH,AAAA,AAAAyR,AAAAD;AAAAE,AAAA,AAAAlN,AAAAiN;AAAAE,AAAA,AAAA/M,AAAA8M;AAAAA,AAAA,AAAA7M,AAAA6M;AAAAC,AACQE;AADRH,AACexN;AADf,AAEE,AAAA4N,AAGM,AAAO7I,AAAqC,AAACzE,AAAIN;AAAjD,AACOyB;AADP,AAEOsM;AAFP,AAGOC;;AAHP,AAIE,AAAIjJ;AACF,AAAMrH,AAAK,AAACgD,AAAMqE;AACZA,AAAM,AAACpE,AAAKoE;AADlB,AAEE,AAAM,AAAK,AAAClB,AAAKnG,AAAM,AAAA,AAAA,AAACX,AAAS,AAAC2D,AAAMhD;AAClC,AAAOqH;AAAMtD;AAAW,AAACb,AAAKmN,AAAYrQ;AAAMsQ;;;;;;;AADtD,AAEM,AAAK,AAACpP,AAAImG,AAAO,AAAK,AAAClB,AAAKnG,AAAM,AAAA,AAAA,AAACX,AAAW,AAAC2D,AAAMhD;AAF3D,AAGO+D,AAAWsM,AAAYrQ;;AAH9B,AAOM,AAAOqH;AAAM,AAACnE,AAAKa,AAAW/D;AAAMqQ;AAAYC;;;;;;;;;;AAV1D,AAWGvM,AAAWsM,AAAYC;;;;;AAlBlC,AAAA/P,AAAA2P,AAAA,AAAA,AAAOnM;AAAP,AAAAxD,AAAA2P,AAAA,AAAA,AACOC;AADP,AAAA5P,AAAA2P,AAAA,AAAA,AAEOE;AAiBD9N,AAAK,AAAAiO,AAASnS;AAAToS,AAAa,AAAA,AAAA,AAACvK,AAASlC;AAAvB,AAAA,AAAAwM,AAAAC,AAAAD,AAAAC,AAACrO,AAAAA,AAAAA;;AACNgO,AAAQ,AAACjO,AAAK,AAAKrC;AAAL,AACE,AAAA4Q,AAA4B5Q;AAA5B6Q,AAAA,AAAA9N,AAAA6N;AAAAE,AAAA,AAAA3N,AAAA0N;AAAAA,AAAA,AAAAzN,AAAAyN;AAAAC,AAAO3P;AAAP2P,AAAA,AAAA3N,AAAA0N;AAAAA,AAAA,AAAAzN,AAAAyN;AAAAC,AAASC;AAATD,AAAA,AAAA3N,AAAA0N;AAAAA,AAAA,AAAAzN,AAAAyN;AAAAC,AAAYE;AAAZH,AAAsBpO;AAAtB,AACE,AAAArB,AAAe,AAACtB,AAAsBvB,AAAIwS;AAA1C,AAAA,AAAA3P;AAAA,AAAAA,AAASvB;AAAT,AAAA,AAAA,AAAA,AAAA,AACUA,AACEmR,AACH,AAAAC,AAAS,AAAA,AAAA,AAAA,AAAC1K,AAAShI,AAAeyS;AAAlCE,AACS,AAAA,AAAA,AAAC9K,AAAS3D;AADnB,AAAA,AAAAwO,AAAAC,AAAAD,AAAAC,AAAC5O,AAAAA,AAAAA;;;AAER,AAACpE,AAA0B,AAAA,AAAqC6S,AAAIA;;AAC1ET;AACdC,AAAQ,AAAA,AAAMA,AACJ,AAAAY,AAAS5S;AAAT6S,AAAa,AAAA,AAAA,AAAChL,AAAS,AAACoH,AAAK+C;AAA7B,AAAA,AAAAY,AAAAC,AAAAD,AAAAC,AAAC9O,AAAAA,AAAAA;AADH;AA7Bd,AA+BE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAChB,AAESmB,AACG6N,AACAC;;AAGjB,AAAA,AAAAc,AAAMzG,AAAgBrM;AAAtB,AAAA,AAAA+S,AAAAD;AAAAE,AAAA,AAAAxO,AAAAuO;AAAAE,AAAA,AAAArO,AAAAoO;AAAAA,AAAA,AAAAnO,AAAAmO;AAAAC,AAA2BC;AAA3BF,AAAsCG;AAAtCJ,AAAgDK;AAAhD,AACE,AAACC,AAAM,AAAA,AAAMrT,AACN,AAAKF;AAAL,AACE,AAAMW,AAAI,AAACC;AAAX,AACE,AAAA,AAAA,AAAC4S,AAAUxT,AAAiBW,AACjB,AAAK8S;AAAL,AACE,AAACrL,AAAO,AAAKK,AAAI6C;AAAT,AACE,AAAI,AAAC1L,AAAU6I,AAAI6C;AAGjB7C;;AACA,AAACX,AAAMW,AAAI6C,AACJ,AAAAoI,AAAM,AAAA,AAACC,AAAkB,AAACnT,AAAO,AAAKG,AACL,AAAK2K,AACjB,AAAA,AAAA,AAAA,AAAAlL,AAAA,AAAA,AAAAA,AAAC0H,AAAM,AAACpI,AAAK4L,AACAA,AACDqB,AACEiH;AALnC,AAAA,AAAAF;;AAAAA;;;AAOXD,AACAJ;;;;AApBlC;;AAuBA,AAAA,AAAAQ,AAAAC,AAAMK;AAAN,AAAA,AAAAJ,AAAAF;AAAAE,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAjV,AAAA,AAAAiV,AAAA,AAAA,AAAA,AAAA,AAAAhV,AAAAC,AAAA+U,AAAAA;AAAAA,AAAmC7T;AAAnCF,AAAA,AAAAd,AAAA6U,AAAA;AAAAC,AAAAF;AAAAG,AAAA,AAAAvP,AAAAsP;AAAAE,AAAA,AAAApP,AAAAmP;AAAAA,AAAA,AAAAlP,AAAAkP;AAAAC,AAAyCpR;AAAzCmR,AAA6CG;AAA7CJ,AAAyElS;AAAzE,AACE,AAAMuS,AAAM,AAAA,AAAAC,AAACpN;AAAD,AAAM,AAAI,AAAK,AAAAoN,AAACrM,AAAQ,AAAA,AAAA,AAAC9G,AAAS,AAAAmT,AAACxP;AAAW,AAAAwP,AAAC9Q;;AAAzC8Q;;AACDF;AADjB,AAEE,AAAAG,AAAA,AAAA7P,AAAa,AAAC0D,AAAO;AAAK9G,AAAEyT;AAAP,AACE,AAAI,AAAAlQ,AAASkQ;AACX,AAAC/P,AAAK1D,AAAE,AAACZ,AAAKqU;;AACd,AAAMC,AAAE,AAAClQ,AAAMiQ;AAAME,AAAG,AAAC9F,AAAK4F;AAA9B,AACE,AAAC9O,AAAK3E,AAAE,AAAA,AAAA4T,AAAChO;AAAD,AAAM,AAAA,AAAAgO,AAAKF;AAASC;;;AAJ1C,AAKWZ;AALxBG,AAAA;AAAAC,AAAA;AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAAE,AAAQK;AAAR,AAAA,AAME,AAAMI,AAAc,AAAC3U,AAAOuU;AAA5B,AACE,AAAU,AAACtT,AAAsBvB,AAAIiV;AAArC;AAAA,AACE,AAACtV,AAA0B,AAAA,AAAqCsV,AAAerT;;;AACjF,AAAMsT,AAAS,AAAA,AAACC,AAAkBN;AAC5BO,AAAW,AAAC1R,AAAKmR,AAAK,AAAA,AAAKK,AAAU,AAAC7O,AAAMwO;AAC5CpU,AAAI,AAACC;AAFX,AAGE,AAAA,AAAA,AAAA,AAAC2S,AAAMvT,AAAIkI,AAAsBvH,AAAa,AAACH,AAAO8U,AAAaH;;AAZzE;AAAA,AAAAZ;AAAAC;AAAAC;AAAA,AAAAC,AAAA;;;;;;;AAAA,AAAArT,AAAA,AAAAqD,AAAA6P;AAAA,AAAA,AAAAlT;AAAA,AAAA,AAAAkT,AAAAlT;AAAA,AAAA,AAAA,AAAAsT,AAAAJ;AAAA,AAAAK,AAAA,AAAAC,AAAAN;AAAA,AAAA,AAAA,AAAAO,AAAAP;AAAAK;AAAA,AAAArO,AAAAqO;AAAA;;;;;;;AAAA,AAAA,AAAA9P,AAAAyP,AAAQQ;AAAR,AAAA,AAME,AAAMI,AAAc,AAAC3U,AAAOuU;AAA5B,AACE,AAAU,AAACtT,AAAsBvB,AAAIiV;AAArC;AAAA,AACE,AAACtV,AAA0B,AAAA,AAAqCsV,AAAerT;;;AACjF,AAAMsT,AAAS,AAAA,AAACC,AAAkBN;AAC5BO,AAAW,AAAC1R,AAAKmR,AAAK,AAAA,AAAKK,AAAU,AAAC7O,AAAMwO;AAC5CpU,AAAI,AAACC;AAFX,AAGE,AAAA,AAAA,AAAA,AAAC2S,AAAMvT,AAAIkI,AAAsBvH,AAAa,AAACH,AAAO8U,AAAaH;;AAZzE;AAAA,AAAA,AAAApQ,AAAAwP;AAAA;AAAA;AAAA;;;;;;;;AAAA;;;;;;AAgBJ,AAAA,AAAAgB,AAAMI,AAAYzV;AAAlB,AAAA,AAAAsV,AAAAD;AAAAE,AAAA,AAAA/Q,AAAA8Q;AAAAE,AAAA,AAAA5Q,AAAA2Q;AAAAA,AAAA,AAAA1Q,AAAA0Q;AAAAC,AAAuBE;AAAvBF,AAAA,AAAA5Q,AAAA2Q;AAAAA,AAAA,AAAA1Q,AAAA0Q;AAAAC,AAA4BG;AAA5BH,AAAA,AAAA5Q,AAAA2Q;AAAAA,AAAA,AAAA1Q,AAAA0Q;AAAAC,AAA0CI;AAA1CL,AAAwDM;AAAxDP,AAAiElC;AAAjE,AACE,AAAA0C,AAA2B,AAAI,AAAC/N,AAAK6N,AAAaA,AACnB,AAAC/N,AAAK+N,AAAYC;AADjDE,AAAA,AAAAvR,AAAAsR;AAAAE,AAAA,AAAApR,AAAAmR;AAAAA,AAAA,AAAAlR,AAAAkR;AAAAC,AAAOJ;AAAPG,AAAqBF;AAEfF,AAAc,AAAC5R,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAI2V,AAAAA;AAC3BA,AAAc,AAACM,AACAN,AACA,AAAK9T;AAAL,AACE,AAAAgB,AAAW,AAAA,AAAMhB;AAAjB,AAAA,AAAAgB;AAAA,AAAAA,AAASN;AAAT,AACE,AAAMjB,AAAM,AAAAT,AAAI,AAACU,AAAsBvB,AAAIuC;AAA/B,AAAA,AAAA1B;AAAAA;;AACI,AAAClB,AACA,AAAA,AAAqC4C,AAAGA;;;AAFzD,AAGE,AAAA,AAACqF,AAAM/F,AAAaP;;AACtBO;;;AACnB+T,AAAY,AAACpV,AAAKoV;AAClBC,AAAK,AAAClS,AAAiB3D,AAAI6V;AAbjC,AAAAtR,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAcMrB,AAIoBsS,AAAeC,AAAaC;AAlBtD,AAmBE,AAAClM,AAAetG;;AAEpB;;;AAAA,AAAM6S,AAEHlW,AAAI4B;AAFP,AAGE,AAAM,AAAA,AAAG,AAACyE,AAAMzE;AAAhB,AACE,AAAO,AAAA,AAA4CuB;;AADrD;;AAGA,AAACsS,AAAWzV,AAAI4B;;AAElB;;;AAAA,AAAAuU,AAAMI,AAEHvW;AAFH,AAAA,AAAAoW,AAAAD;AAAAE,AAAA,AAAA7R,AAAA4R;AAAAE,AAAA,AAAA1R,AAAAyR;AAAAA,AAAA,AAAAxR,AAAAwR;AAAAC,AAEQE;AAFRF,AAAA,AAAA1R,AAAAyR;AAAAA,AAAA,AAAAxR,AAAAwR;AAAAC,AAEoBG;AAFpBJ,AAE0BR;AAF1BO,AAEmCxU;AAFnC,AAGE,AAAM,AAAA,AAAG,AAACyE,AAAMzE;AAAhB,AACE,AAAO,AAAA,AAA4CuB;;AADrD;;AAGA,AAACsS,AAAWzV,AAAI,AAAA0E,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAS+R,AAAI,AAAC5O,AAAK,AAACvH,AAAO,AAAA,AAACoD,AAAK,AAAClD,AAAKgW,AAAiBX;;AAE1E,AAAA,AAAAa,AAAMI,AAAY9W;AAAlB,AAAA,AAAA2W,AAAAD;AAAAE,AAAA,AAAApS,AAAAmS;AAAAE,AAAA,AAAAjS,AAAAgS;AAAAA,AAAA,AAAA/R,AAAA+R;AAAAC,AAAuBE;AAAvBF,AAAA,AAAAjS,AAAAgS;AAAAA,AAAA,AAAA/R,AAAA+R;AAAAC,AAA4BG;AAA5BJ,AAAwCf;AAAxC,AACE,AAAAhT,AACoD,AAACuU,AAA2BpX,AAAIgX;AADpF,AAAA,AAAAnU;AAAA,AAAAoU,AAAApU;AAAAoU,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAArY,AAAA,AAAAqY,AAAA,AAAA,AAAA,AAAA,AAAApY,AAAAC,AAAAmY,AAAAA;AAAAA,AAC4CE;AAD5CD,AAAA,AAAAlY,AAAAiY,AAAA;AAAA,AAEE,AAAMpB,AAAK,AAAClS,AAAiB3D,AAAI6V;AAAjC,AACE,AAAClM,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAA+BwS,AAAarB;;AAC9D,AAAClW,AAA0B,AAAA,AAAqCqX,AAAWA;;;AAE/E,AAAA,AAAAK,AAAMI,AAAoBzX;AAA1B,AAAA,AAAAsX,AAAAD;AAAAE,AAAA,AAAA/S,AAAA8S;AAAAE,AAAA,AAAA5S,AAAA2S;AAAAA,AAAA,AAAA1S,AAAA0S;AAAAC,AAA+BE;AAA/BH,AAAiD1B;AAAjD,AACE,AAGM8B,AAAiB,AAACnX,AAAKkX;AACvBV,AAAU,AAACjU,AAAU,AAACzC,AAAO,AAAA,AAACoD,AAAKiU,AACA,AAAA,AAAK,AAAOA,AACnC,AAACnY,AAAKkY;AANxB,AAOE,AAACZ,AAAW9W,AAAI,AAAC+C,AAAU,AAAA,AAAA,AAAC2M,AAAWsH,AAAUnB,AAC/B,AAACrW,AAAKkY;;AAM5B,AAAA,AAAAE,AAAMI,AAAiBhY;AAAvB,AAAA,AAAA6X,AAAAD;AAAAE,AAAA,AAAAtT,AAAAqT;AAAAE,AAAA,AAAAnT,AAAAkT;AAAAA,AAAA,AAAAjT,AAAAiT;AAAAC,AAA4BE;AAA5BF,AAAA,AAAAnT,AAAAkT;AAAAA,AAAA,AAAAjT,AAAAiT;AAAAC,AAAgCG;AAAhCJ,AAA0C7O;AAA1C,AACE,AAAU,AAAAtE,AAASuT;AAAnB;AAAA,AACE,AAAO,AACc/U,AACT,AAAA,AAA4C,AAACgV,AAAOD;;;AAClE,AAAAE,AACM,AAAME,AAAM,AAAC1T,AAAMqE;AAAnB,AACE,AAAI,AAASqP;AAAb,AACGA,AAAM,AAACzT,AAAKoE;;AADf,AAAA,AAEOA;;;AAJf,AAAA9G,AAAAiW,AAAA,AAAA,AAAO7L;AAAP,AAAApK,AAAAiW,AAAA,AAAA,AAAiBnP;AAAjBoP,AAOM,AAAMxW,AAAE,AAAC+C,AAAMqE;AAAf,AACE,AAAI,AAACrC,AAAK/E;AAAV,AACGA,AAAE,AAACgD,AAAKoE;;AADX,AAAA,AAEOA;;;AAVf,AAAA9G,AAAAkW,AAAA,AAAA,AAMOE;AANP,AAAApW,AAAAkW,AAAA,AAAA,AAMgBpP;AAKVsP,AAAS,AAAIhM,AACF,AAAA,AAAC3E,AAAM2Q,AAAchM,AACrBgM;AAbjB,AAcE,AAACC,AAAexY,AAAIkY,AAAQK;;AAC5B,AAAOtP,AAAMA;AAAb,AACOsI;;AADP,AAEE,AAAItI;AACF,AAAAwP,AAAiB,AAAC7T,AAAMqE;AAAxByP,AAAA,AAAAlU,AAAAiU;AAAAE,AAAA,AAAA/T,AAAA8T;AAAAA,AAAA,AAAA7T,AAAA6T;AAAAC,AAAOvW;AAAPsW,AAAW7C;AAAX,AACE,AAAA+C,AAAMxW;AAANwW,AAAA,AAAA,AAAAA,AAAAC,AAAA,AAAAD,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA;AAEE,AAAO,AAAC/T,AAAKoE;AACN,AAACnE,AAAKyM,AACA,AAAC5H,AACA,AAAC+F,AAAM,AAACpP,AAAO,AAACE,AAAK4B,AAAIyT;;;;;;AALzC;AAMU,AAEE,AAAA,AAAAtR,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACuP,AAAUjU,AAAiB6V;;AAC5B,AAAO,AAAChR,AAAKoE;AAAOsI;;;;;;AAThC;AAUiB,AAAO,AAAC1M,AAAKoE;AACN,AAACnE,AAAKyM,AACA,AAAC5H,AACA,AAAA,AAAA,AAAA,AAAA,AAAC+F,AAA2BmG;;;;;;AAb3D;AAeE,AAAO,AAAChR,AAAKoE;AAAOsI;;;;;;;AAftB,AAAA,AAAApO,AAAA,AAAA,AAAAyV;;;;AAgBF,AAACjP,AAAe,AAAA,AAAA,AAAC+F,AAAU6B;;;;;AAOnC,AAAA,AAAAuH,AAAME,AAAahZ;AAAnB,AAAA,AAAA+Y,AAAAD;AAAA,AAAA3W,AAAA4W,AAAA,AAAA,AAAwBnW;AAAxB,AAAAT,AAAA4W,AAAA,AAAA,AAA0B/M;AAA1B,AACE,AAAC5I,AAAe,AAAA,AAAA,AAACwE,AAAM5H,AAAkCgM;;AAE3D,AAAA,AAAAiN,AAAME,AAAcnZ;AAApB,AAAA,AAAAkZ,AAAAD;AAAA,AAAA9W,AAAA+W,AAAA,AAAA,AAAyBtW;AAAzB,AAAAT,AAAA+W,AAAA,AAAA,AAA2BzC;AAA3B,AAAAtU,AAAA+W,AAAA,AAAA,AAA+B9X;AAA/B,AACE,AAAMqV,AAAI,AAAC1S,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIyW,AAAAA;AACjBrV,AAAE,AAAC2C,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIoB,AAAAA;AACfqV,AAAI,AAAC2C,AAAa3C;AAFxB,AAGE,AAAC9M,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAY+R,AAAIrV;;AAMpC,AAAA,AAAMiY,AAAQtL;AAAd,AACE,AAAA5M,AAAa,AAAC3B,AAAKuO;AAAnB,AAAA,AAAA5M;AAAA,AAAA,AAAAA,AAAWU;AAAX,AACE,AAAAhB,AAAI,AAAA,AAAYgB;AAAhB,AAAA,AAAAhB;AAAAA;;AACI,AAAA,AAAQgB;;;AAFd;;;AAMF,AAAA,AAAMyX,AAActZ,AAAI4B;AAAxB,AACE,AAAMmM,AAAE,AAACnJ,AAAMhD;AAAf,AACE,AAAI,AAAA+C,AAASoJ;AACX,AAEMwL,AAAY,AAACva,AAAIR,AAAauP;AAC9BnL,AAAE,AAAA,AAAA,AAAM2W,AAAY,AAACra,AAAkBc,AAAIuZ,AAAYxL;AACvDA,AAAE,AAAAlN,AAAI0Y;AAAJ,AAAA,AAAA1Y;AAAAA;;AACI,AAAA,AAACuC,AAAepD,AAAI+N;;;AAC1BA,AAAE,AAAI,AAAK,AAACyL,AAAUzL,AACX,AAAAlN,AACC,AAAC4Y,AAAa1L;AADf,AAAA,AAAAlN;AAAAA;;AAEC,AAAA,AAAA,AAAIkN,AAAEvO;;AAHhB,AAAAU,AAAI,AAID6N,AAAEA;AAVb,AAWE,AAAI,AAAK,AAACjL,AAAI,AAAC4W,AAAM3L,AACZ,AAAAlN,AACC0Y;AADD,AAAA,AAAA1Y;AAAAA;;AAEC,AAACnB,AAAUjB,AAAOsP;;AAHxB;AAIF,AAAA4L,AAAM5L;AAAN,AAAA,AAAA,AAAA9M,AAAA,AAAA,AAAA0Y;AAgCI,AAACzD,AAAalW,AAAI4B;;AAhCtB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAmCS,AAAC1F,AAAUjU,AAAI4B;;AAnCxB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AA4BO,AAACtJ,AAAYrQ,AAAI4B;;AA5BxB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAQW,AAAA,AAAClS,AAAUzH,AAAI4B;;AAR1B,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AA2BK,AAACzJ,AAAUlQ,AAAI4B;;AA3BpB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAWkB,AAAMpI,AAAI,AAACvE,AAAYhN,AAAI4B;AAA3B,AACE2P;;AAZpB,AAAA,AAAAtQ,AAAA,AAAA,AAAA0Y;AAWkB,AAAMpI,AAAI,AAACvE,AAAYhN,AAAI4B;AAA3B,AACE2P;;AAZpB,AAAA,AAAAtQ,AAAA,AAAA,AAAA0Y;AAmBU,AAACC,AAAe5Z,AAAI4B;;AAnB9B,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAKK,AAAChQ,AAAe,AAAA,AAAA,AAAC9B,AACK,AAAClE,AAAiB3D,AAAI,AAACiP,AAAKrN;;AANvD,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAoBO,AAAChL,AAAY3O,AAAI4B;;AApBxB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AA0BQ,AAAAG,AAAS9Z;AAAT+Z,AAAa,AAACC,AAAaha,AAAI4B;AAA/B,AAAA,AAAAkY,AAAAC,AAAAD,AAAAC,AAAChW,AAAAA,AAAAA;;AA1BT,AAAA,AAAA9C,AAAA,AAAA,AAAA0Y;AAiCqB,AAAClC,AAAmBzX,AAAI4B;;AAjC7C,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AASM,AAAC7N,AAAW9L,AAAI4B;;AATtB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AA8BU,AAACtN,AAAerM,AAAI4B;;AA9B9B,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAiBQ,AAAA;AAAQ,AAACrW,AAAO1B;;AAjBxB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AA+Bc,AAACpD,AAAYvW,AAAI4B;;AA/B/B,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAoCK,AAAC3B,AAAgBhY,AAAI4B;;AApC1B,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAsBM,AAAMtW,AAAI,AAACwW,AAAW7Z,AAAI4B;AAA1B,AACE,AAAI,AAAA,AAA0B5B;AAC5BqD;;AACA,AAACU,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIqD,AAAAA;;;AAzBvB,AAAA,AAAApC,AAAA,AAAA,AAAA0Y;AAOM,AAAC3P,AAAWhK,AAAI4B;;AAPtB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAQW,AAAA,AAAClS,AAAUzH,AAAI4B;;AAR1B,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAsCO,AAACR,AAAanZ,AAAI4B;;AAtCzB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAkCM,AAAC7C,AAAW9W,AAAI4B;;AAlCtB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAcK,AAACnP,AAASxK,AAAI,AAACiP,AAAKrN;;AAdzB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAqCM,AAACX,AAAYhZ,AAAI4B;;AArCvB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAgBO,AAACzO,AAAYlL,AAAI4B;;AAhBxB,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AAqBW,AAAChK,AAAgB3P,AAAI4B;;AArBhC,AAAA,AAAAX,AAAA,AAAA,AAAA0Y;AA6BM,AAAC/H,AAAW5R,AAAI4B;;AA7BtB,AA0CE,AAAC+H,AAAe,AAAC9B,AAAKkG,AAAE,AAACpK,AAAiB3D,AAAI,AAACiP,AAAKrN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACtD,AAAA,AACE,AAAI,AAACyX,AAAOtL;AACV,AAAMmM,AAAW,AAAAC,AAAA;AAAAC,AACe,AAAA,AAAc,AAAC5a,AAAKuO;AADnC,AAAA,AAAAoM,AAAAC,AAAAD,AAAAC,AAAC7a,AAAAA,AAAAA;;AAEZ6B,AAAE,AAAI8Y,AACF,AAACrb,AAAMkP,AAAEnM,AACF,AAAA,AAAW5B,AACXA,AACA,AAACiP,AAAKrN,AACb,AAAC/C,AAAMkP,AAAEnM,AACF,AAAA,AAAW5B,AAAK,AAACiP,AAAKrN;AACjC+I,AAAS,AAAI,AAAA,AAA0B3K,AAC5BoB,AACA,AAAC2C,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIoB,AAAAA;AAX9B,AAYEuJ;;AACF,AAAChB,AAAe,AAAC9B,AAAKkG,AAAE,AAACpK,AAAiB3D,AAAI,AAACiP,AAAKrN;;AAfxD,AAAA,AAAAqY,AAgBiC9W;AAhBjC,AAAA8W,AAgB2CtT;AAhB3C,AAiBI,AAAC0T,AAA8Bra,AAAI2G,AAAE/E;;AAjBzC,AAAA,AAAAqY;;;;;AAkBJ,AAAM1I,AAAI,AAAC5H,AAAe,AAAChG,AAAiB3D,AAAI4B;AAAhD,AACE2P;;;AAER,AAAA,AAAMxN,AACH/D,AAAI4B;AADP,AAGE,AAAM2P,AAAI,AAAA,AAAM,AAAC+I,AAAU1Y,AAAMA,AACjB,AAAA+C,AAAS/C,AAAM,AAAMR,AAAE,AAAA,AAACgC,AAAepD,AAAI4B;AAA5B,AACE,AAAM,AAAC0Y,AAAUlZ;AAAGA;;AAApB,AAEM,AAACoY,AAAUpY;AAAG,AAAI,AAAA,AAAQ,AAAC5B,AAAK4B;AAAlB,AAAAlB,AACGkB;;AAAE,AAACmZ,AAAgBnZ;;;AAH1C,AAIY,AAACoZ,AAAWpZ,AAAE,AAAC5B,AAAKoC;;;;AANvD,AAQM,AAAC4Y,AACA,AAAA,AAAA,AAAA,AACE,AAAC5T,AAAKhF,AACN,AAAI,AAACuF,AAAO,AAACxD,AAAiB3D,AAAI,AAACya,AAAK7Y,AAC5B,AAAC+B,AAAiB3D,AAAI,AAAC0a,AAAK9Y,AACpC+Y,AACJ,AAAI,AAAC9U,AAAQjE,AAAM,AAACgZ,AAAKhZ,AACzB,AAAI,AAACmE,AAAK,AAAC8U,AAAMjZ,AAAM,AAAC+B,AAAiB3D,AAAI4B,AACzC+Y,AACJ,AAAK,AAAC5S,AAAKnG,AAAM,AAAC4C,AAAI5C,AACtB,AAAC0X,AAAatZ,AAAI4B,AACZA;AACR,AAAA,AAAA,AAAA,AAAA,AAACkZ,AAAY,AAACtb,AAAKoC;;AApBpC,AAuBE2P;;AAIJ","names":["sci.impl.analyzer/special-syms","sci.impl.analyzer/macros","p__97368","map__97369","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","allow","cljs.core.get","deny","sci.impl.analyzer/check-permission!","check-sym","sym","G__97371","G__97372","sci.impl.utils/kw-identical?","cljs.core/meta","sci.impl.utils/strip-core-ns","cljs.core/contains?","sci.impl.utils.throw_error_with_location","p__97376","map__97377","env","sci.impl.analyzer/lookup*","ctx","call?","cljs.core/deref","sym-ns","G__97379","cljs.core/namespace","cljs.core.symbol","sym-name","cljs.core/name","cnn","sci.impl.vars/current-ns-name","the-current-ns","G__97382","or__4126__auto__","cljs.core.get_in","cljs.core/find","and__4115__auto__","cljs.core._EQ_","G__97385","temp__5735__auto__","v","G__97389","clazz","sci.impl.interop/resolve-class","G__97391","c","sci.impl.analyzer/tag","_ctx","expr","m","p__97401","map__97402","bindings","sci.impl.analyzer/lookup","vec__97409","cljs.core.nth","k","kv","vec__97420","t","sci.impl.utils/mark-resolve-sym","cljs.core.vary_meta","cljs.core/assoc","vec__97423","_","temp__5733__auto__","cljs.core/not","cljs.core/with-meta","var_args","G__97431","sci.impl.analyzer/resolve-symbol","js/Error","sci.impl.analyzer.resolve_symbol","res","cljs.core/second","n","clojure.string/starts-with?","clojure.string/ends-with?","cljs.core.subs","sci.impl.analyzer/analyze-children","children","p1__97438#","cljs.core.mapv","sci.impl.analyzer/analyze","sci.impl.analyzer/maybe-destructured","params","body","cljs.core/every?","cljs.core/symbol?","new-params","lets","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/Symbol","cljs.core/first","cljs.core/next","cljs.core.conj","gparam","cljs.core.gensym","p__97444","p__97445","map__97447","fn-expr","vec__97448","seq__97449","first__97450","sci.impl.analyzer/expand-fn-args+body","fn-name","binding-vector","body-exprs","macro?","cljs.core/vector?","map__97459","cljs.core.into","fixed-args","p1__97439#","cljs.core.take_while","cljs.core.not_EQ_","fixed-arity","cljs.core/count","var-arg-name","p1__97440#","cljs.core.drop_while","next-body","conds","e","cljs.core/map?","pre","post","cljs.core/vec","cljs.core.map","cljs.core.update","cljs.core/merge","cljs.core/zipmap","cljs.core.repeat","p__97480","vec__97481","seq__97482","first__97483","sci.impl.analyzer/expand-fn","_fn","name?","cljs.core.assoc","cljs.core/cons","bodies","cljs.core/seq?","cljs.core/assoc-in","analyzed-bodies","cljs.core.reduce","p__97494","map__97495","max-fixed","min-varargs","acc","arglist","new-min-varargs","x__4214__auto__","y__4215__auto__","cljs.core/conj","arities","arglists","sci.impl.analyzer/expand-let*","destructured-let-bindings","exprs","vec__97502","new-let-bindings","p__97506","p__97507","vec__97510","vec__97513","binding-name","binding-value","cljs.core.partition","sci.impl.utils/mark-eval-call","p__97518","vec__97520","seq__97521","first__97522","sci.impl.analyzer/expand-let","_let","let-bindings","sci.impl.destructure/destructure","p__97534","vec__97535","seq__97536","first__97537","sci.impl.analyzer/expand->","x","forms","expanded","form","threaded","p__97550","vec__97551","seq__97552","first__97553","sci.impl.analyzer/expand-as->","_as","name","vec__97554","seq__97555","first__97556","cljs.core.interleave","cljs.core/butlast","cljs.core/empty?","cljs.core/last","p__97557","vec__97558","sci.impl.analyzer/expand-def","_def","var-name","?docstring","?init","G__97561","G__97562","sci.impl.analyzer/expand-declare","cljs.core/simple-symbol?","docstring","init","sci.impl.vars/current-ns","G__97563","G__97564","p__97565","vec__97566","seq__97567","first__97568","sci.impl.analyzer/expand-defn","op","G__97569","G__97570","vec__97571","pre-body","cljs.core/split-with","cljs.core.comp","cljs.core/sequential?","ds","meta-map","G__97574","G__97575","cljs.core.merge","fn-body","f","G__97576","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.impl.analyzer/expand-comment","seq97577","G__97578","self__4723__auto__","_body","sci.impl.analyzer/expand-loop","vec__97580","bv","arg-names","cljs.core.take_nth","init-vals","cljs.core/rest","syms","cljs.core.repeatedly","bv1","cljs.core/vector","bv2","cljs.core/cat","cljs.core/nnext","expansion","cljs.core.list_STAR_","sci.impl.analyzer/expand-lazy-seq","G__97584","G__97585","p__97586","vec__97587","seq__97588","first__97589","sci.impl.analyzer/expand-if","_if","G__97590","sci.impl.analyzer/expand-case","G__97593","G__97594","clauses","match-clauses","result-clauses","default","cljs.core/odd?","G__97595","G__97596","cases","assoc-new","case-map","ret-map","vec__97605","seq__97606","first__97607","cljs.core/list?","ret","p__97609","vec__97610","seq__97611","first__97612","sci.impl.analyzer/expand-try","_try","vec__97613","catches","finally","catch-exprs","finally-expr","G__97620","G__97621","vec__97622","seq__97623","first__97624","ex","binding","G__97625","G__97626","G__97627","G__97628","p__97629","vec__97630","seq__97631","first__97632","_declare","names","_expr","cljs.core.swap_BANG_","cljs.core.update_in","current-ns","G__97633","sci.impl.vars/->SciVar","sci.impl.vars/current-file","p__97636","p__97637","map__97638","vec__97643","seq__97644","first__97645","sci.impl.analyzer/do-import","import-symbols-or-lists","specs","p1__97634#","seq__97650","chunk__97651","count__97652","i__97653","cljs.core/chunked-seq?","c__4556__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","spec","p","cs","p1__97635#","fq-class-name","last-dot","clojure.string.last_index_of","class-name","p__97673","vec__97675","seq__97676","first__97677","sci.impl.analyzer/expand-dot","_dot","instance-expr","method-expr","args","vec__97679","seq__97680","first__97681","sci.impl.utils/vary-meta*","sci.impl.analyzer/expand-dot**","p__97684","vec__97685","seq__97686","first__97687","sci.impl.analyzer/expand-dot*","method-name","obj","p__97688","vec__97689","seq__97690","first__97691","sci.impl.analyzer/expand-new","_new","class-sym","map__97692","constructor","_opts","sci.impl.interop/resolve-class-opts","p__97695","vec__97696","seq__97697","first__97698","sci.impl.analyzer/expand-constructor","constructor-sym","constructor-name","p__97699","vec__97700","seq__97701","first__97702","sci.impl.analyzer/analyze-ns-form","_ns","ns-name","cljs.core.pr_str","vec__97703","vec__97706","fexpr","attr-map","sci.impl.utils/set-namespace!","vec__97713","seq__97714","first__97715","G__97716","cljs.core/Keyword","p__97720","vec__97721","sci.impl.analyzer/analyze-var","p__97724","vec__97725","sci.impl.analyzer/analyze-set!","sci.impl.types/getVal","sci.impl.analyzer/macro?","sci.impl.analyzer/analyze-call","special-sym","sci.impl.vars/var?","sci.impl.vars/isMacro","sci.impl.utils/eval?","G__97729","sci.impl.analyzer.expand_comment","sci.impl.for-macro/expand-for","G__97732","G__97733","sci.impl.doseq-macro/expand-doseq","e97740","needs-ctx?","G__97741","G__97742","sci.impl.utils/rethrow-with-location-of-node","sci.impl.utils/constant?","sci.impl.types/->EvalVar","sci.impl.utils/merge-meta","cljs.core/keys","cljs.core/vals","sci.impl.utils/mark-eval","cljs.core/set?","cljs.core/empty","cljs.core/select-keys"],"sourcesContent":["(ns sci.impl.analyzer\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-all macroexpand-1])\n  (:require\n   [clojure.string :as str]\n   [sci.impl.destructure :refer [destructure]]\n   [sci.impl.doseq-macro :refer [expand-doseq]]\n   [sci.impl.for-macro :refer [expand-for]]\n   [sci.impl.interop :as interop]\n   [sci.impl.types :as types]\n   [sci.impl.utils :as utils :refer\n    [eval? mark-resolve-sym mark-eval mark-eval-call constant?\n     rethrow-with-location-of-node throw-error-with-location\n     merge-meta kw-identical? strip-core-ns set-namespace!]]\n   [sci.impl.vars :as vars]))\n\n;; derived from (keys (. clojure.lang.Compiler specials))\n;; (& monitor-exit case* try reify* finally loop* do letfn* if clojure.core/import* new deftype* let* fn* recur set! . var quote catch throw monitor-enter def)\n(def special-syms '#{try finally do if new recur quote catch throw def . var set!})\n\n;; Built-in macros.\n\n(def macros '#{do if and or -> as-> quote quote* let fn fn* def defn\n               comment loop lazy-seq for doseq case try defmacro\n               declare expand-dot* expand-constructor new . import in-ns ns var\n               set! resolve macroexpand-1 macroexpand the-ns})\n\n(defn check-permission! [{:keys [:allow :deny]} check-sym sym]\n  (when-not (kw-identical? :allow (-> sym meta :line))\n    (let [check-sym (strip-core-ns check-sym)]\n      (when-not (if allow (contains? allow check-sym)\n                    true)\n        (throw-error-with-location (str sym \" is not allowed!\") sym))\n      (when (if deny (contains? deny check-sym)\n                false)\n        (throw-error-with-location (str sym \" is not allowed!\") sym)))))\n\n(defn lookup* [{:keys [:env] :as ctx} sym call?]\n  (let [sym-ns (some-> (namespace sym) symbol)\n        sym-name (symbol (name sym))\n        env @env\n        cnn (vars/current-ns-name)\n        the-current-ns (-> env :namespaces cnn)\n        ;; resolve alias\n        sym-ns (when sym-ns (or (get-in the-current-ns [:aliases sym-ns])\n                                sym-ns))]\n    (or (find the-current-ns sym) ;; env can contain foo/bar symbols from bindings\n        (cond\n          (and sym-ns (or (= sym-ns 'clojure.core) (= sym-ns 'cljs.core)))\n          (or (some-> env :namespaces (get 'clojure.core) (find sym-name))\n              (when-let [v (when call? (get macros sym-name))]\n                [sym v]))\n          sym-ns\n          (or (some-> env :namespaces sym-ns (find sym-name))\n              (when-let [clazz (interop/resolve-class ctx sym-ns)]\n                [sym ^{:sci.impl/op :static-access} [clazz sym-name]]))\n          :else\n          ;; no sym-ns, this could be a symbol from clojure.core\n          (when-not (contains?\n                     (get-in the-current-ns [:refer 'clojure.core :exclude]) sym-name)\n            (or\n             (some-> env :namespaces (get 'clojure.core) (find sym-name))\n             (when (when call? (get macros sym))\n               [sym sym])\n             (when-let [c (interop/resolve-class ctx sym)]\n               [sym c])))))))\n\n(defn tag [_ctx expr]\n  (when-let [m (meta expr)]\n    (:tag m)))\n\n(defn lookup [{:keys [:bindings] :as ctx} sym call?]\n  (let [[k v :as kv]\n        (or\n         ;; bindings are not checked for permissions\n         (when-let [[k v]\n                    (find bindings sym)]\n           ;; never inline a binding at macro time!\n           (let [t (tag ctx v)\n                 v (mark-resolve-sym k)\n                 ;; pass along tag of expression!\n                 v (if t (vary-meta v\n                                    assoc :tag t)\n                       v)]\n             [k v]))\n         (when-let\n             [[k _ :as kv]\n              (or\n               (lookup* ctx sym call?)\n               #_(when (= 'recur sym)\n                   [sym sym]))]\n           (check-permission! ctx k sym)\n           kv))]\n    ;; (prn 'lookup sym '-> res)\n    (if-let [m (and (not (:sci.impl/prevent-deref ctx))\n                    (meta k))]\n      (if (:sci.impl/deref! m)\n        ;; the evaluation of this expression has been delayed by\n        ;; the caller and now is the time to deref it\n        [k (with-meta [v]\n             {:sci.impl/op :deref!})]\n        kv)\n      kv)))\n\n(defn resolve-symbol\n  ([ctx sym] (resolve-symbol ctx sym false))\n  ([ctx sym call?]\n   (let [sym sym ;; (strip-core-ns sym)\n         res (second\n              (or\n               (lookup ctx sym call?)\n               ;; TODO: check if symbol is in macros and then emit an error: cannot take\n               ;; the value of a macro\n               (let [n (name sym)]\n                 (cond\n                   (and call?\n                        (str/starts-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-dot*] ;; method invocation\n                   (and call?\n                        (str/ends-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-constructor]\n                   (str/starts-with? n \"'\") ;; TODO: deprecated?\n                   (let [v (symbol (subs n 1))]\n                     [v v])\n                   :else (throw-error-with-location\n                          (str \"Could not resolve symbol: \" (str sym))\n                          sym)))))]\n     ;; (prn 'resolve sym '-> res (meta res))\n     res)))\n\n(declare analyze)\n\n(defn analyze-children [ctx children]\n  (mapv #(analyze ctx %) children))\n\n(defn maybe-destructured\n  [params body]\n  (if (every? symbol? params)\n    {:params params\n     :body body}\n    (loop [params params\n           new-params (with-meta [] (meta params))\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (-> lets (conj (first params)) (conj gparam)))))\n        {:params new-params\n         :body [`(let ~lets\n                   ~@body)]}))))\n\n(defn expand-fn-args+body [{:keys [:fn-expr] :as ctx} fn-name [binding-vector & body-exprs] macro?]\n  (when-not binding-vector\n    (throw-error-with-location \"Parameter declaration missing.\" fn-expr))\n  (when-not (vector? binding-vector)\n    (throw-error-with-location \"Parameter declaration should be a vector\" fn-expr))\n  (let [binding-vector (if macro? (into ['&form '&env] binding-vector)\n                           binding-vector)\n        fixed-args (take-while #(not= '& %) binding-vector)\n        fixed-arity (count fixed-args)\n        var-arg-name (second (drop-while #(not= '& %) binding-vector))\n        next-body (next body-exprs)\n        conds (when next-body\n                (let [e (first body-exprs)]\n                  (when (map? e) e)))\n        body-exprs (if conds next-body body-exprs)\n        conds (or conds (meta binding-vector))\n        pre (:pre conds)\n        post (:post conds)\n        body-exprs (if post\n                     `((let [~'% ~(if (< 1 (count body-exprs))\n                                    `(do ~@body-exprs)\n                                    (first body-exprs))]\n                         ~@(map (fn* [c] `(assert ~c)) post)\n                         ~'%))\n                     body-exprs)\n        body-exprs (if pre\n                     (concat (map (fn* [c] `(assert ~c)) pre)\n                             body-exprs)\n                     body-exprs)\n        {:keys [:params :body]} (maybe-destructured binding-vector body-exprs)\n        ctx (update ctx :bindings merge (zipmap params\n                                                (repeat nil)))\n        body (analyze-children ctx body)]\n    #:sci.impl{:body body\n               :params params\n               :fixed-arity fixed-arity\n               :var-arg-name var-arg-name\n               :fn-name fn-name}))\n\n(defn expand-fn [ctx [_fn name? & body :as fn-expr] macro?]\n  (let [ctx (assoc ctx :fn-expr fn-expr)\n        fn-name (if (symbol? name?)\n                  name?\n                  nil)\n        body (if fn-name\n               body\n               (cons name? body))\n        ;; fn-name (or fn-name (gensym* \"fn\"))\n        bodies (if (seq? (first body))\n                 body\n                 [body])\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] nil)\n                ctx)\n        analyzed-bodies (reduce\n                         (fn [{:keys [:max-fixed :min-varargs] :as acc} body]\n                           (let [arglist (first body)\n                                 body (expand-fn-args+body ctx fn-name body macro?)\n                                 body (assoc body :sci.impl/arglist arglist)\n                                 var-arg-name (:sci.impl/var-arg-name body)\n                                 fixed-arity (:sci.impl/fixed-arity body)\n                                 new-min-varargs (when var-arg-name fixed-arity)]\n                             (when (and var-arg-name min-varargs)\n                               (throw-error-with-location \"Can't have more than 1 variadic overload\" fn-expr))\n                             (when (and (not var-arg-name) min-varargs (> fixed-arity min-varargs))\n                               (throw-error-with-location\n                                \"Can't have fixed arity function with more params than variadic function\" fn-expr))\n                             (-> acc\n                                 (assoc :min-varargs new-min-varargs\n                                        :max-fixed (max (:sci.impl/fixed-arity body)\n                                                        max-fixed))\n                                 (update :bodies conj body)\n                                 (update :arglists conj arglist))))\n                         {:bodies []\n                          :arglists []\n                          :min-var-args nil\n                          :max-fixed -1} bodies)\n        arities (:bodies analyzed-bodies)\n        arglists (:arglists analyzed-bodies)]\n    (with-meta #:sci.impl{:fn-bodies arities\n                          :fn-name fn-name\n                          :arglists arglists\n                          :fn true}\n      {:sci.impl/op :fn})))\n\n(defn expand-let*\n  [ctx destructured-let-bindings exprs]\n  (let [[ctx new-let-bindings]\n        (reduce\n         (fn [[ctx new-let-bindings] [binding-name binding-value]]\n           (let [v (analyze ctx binding-value)]\n             [(update ctx :bindings assoc binding-name v)\n              (conj new-let-bindings binding-name v)]))\n         [ctx []]\n         (partition 2 destructured-let-bindings))]\n    (mark-eval-call `(~'let ~new-let-bindings ~@(analyze-children ctx exprs)))))\n\n(defn expand-let\n  \"The let macro from clojure.core\"\n  [ctx [_let let-bindings  & exprs]]\n  (let [let-bindings (destructure let-bindings)]\n    (expand-let* ctx let-bindings exprs)))\n\n(defn expand->\n  \"The -> macro from clojure.core.\"\n  [ctx [x & forms]]\n  (let [expanded\n        (loop [x x, forms forms]\n          (if forms\n            (let [form (first forms)\n                  threaded (if (seq? form)\n                             (with-meta (concat (list (first form) x)\n                                                (next form))\n                               (meta form))\n                             (list form x))]\n              (recur threaded (next forms))) x))]\n    (analyze ctx expanded)))\n\n(defn expand-as->\n  \"The ->> macro from clojure.core.\"\n  [ctx [_as expr name & forms]]\n  (let [[let-bindings & body] `([~name ~expr\n                                 ~@(interleave (repeat name) (butlast forms))]\n                                ~(if (empty? forms)\n                                   name\n                                   (last forms)))]\n    (expand-let* ctx let-bindings body)))\n\n(declare expand-declare)\n\n(defn expand-def\n  [ctx [_def var-name ?docstring ?init :as expr]]\n  (expand-declare ctx [nil var-name])\n  (when-not (simple-symbol? var-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (let [docstring (when ?init ?docstring)\n        init (if docstring ?init ?docstring)\n        init (if (= (count expr) 2)\n               :sci.impl/var.unbound\n               (analyze ctx init))\n        m (meta var-name)\n        m (analyze ctx m)\n        m (assoc m :ns @vars/current-ns)\n        m (if docstring (assoc m :doc docstring) m)\n        var-name (with-meta var-name m)]\n    (expand-declare ctx [nil var-name])\n    (mark-eval-call (list 'def var-name init))))\n\n(defn expand-defn [ctx [op fn-name & body :as expr]]\n  (when-not (simple-symbol? fn-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (expand-declare ctx [nil fn-name])\n  (let [macro? (= \"defmacro\" (name op))\n        [pre-body body] (split-with (comp not sequential?) body)\n        _ (when (empty? body)\n            (throw-error-with-location \"Parameter declaration missing.\" expr))\n        docstring (when-let [ds (first pre-body)]\n                    (when (string? ds) ds))\n        meta-map (when-let [m (last pre-body)]\n                   (when (map? m) m))\n        meta-map (analyze ctx (merge (meta expr) meta-map))\n        fn-body (with-meta (cons 'fn body)\n                  (meta expr))\n        f (expand-fn ctx fn-body macro?)\n        arglists (seq (:sci.impl/arglists f))\n        meta-map (assoc meta-map\n                        :ns @vars/current-ns\n                        :arglists arglists)\n        fn-name (with-meta fn-name\n                  (cond-> meta-map\n                    docstring (assoc :doc docstring)\n                    macro? (assoc :macro true)))\n        f (assoc f\n                 :sci/macro macro?\n                 :sci.impl/fn-name fn-name)]\n    (mark-eval-call (list 'def fn-name f))))\n\n(defn expand-comment\n  \"The comment macro from clojure.core.\"\n  [_ctx & _body])\n\n(defn expand-loop\n  [ctx expr]\n  (let [bv (second expr)\n        arg-names (take-nth 2 bv)\n        init-vals (take-nth 2 (rest bv))\n        [bv syms] (if (every? symbol? arg-names)\n                    [bv arg-names]\n                    (let [syms (repeatedly (count arg-names) #(gensym))\n                          bv1 (map vector syms init-vals)\n                          bv2  (map vector arg-names syms)]\n                      [(into [] cat (interleave bv1 bv2)) syms]))\n        body (nnext expr)\n        expansion (list 'let bv\n                        (list* `(fn ~(vec arg-names) ~@body)\n                               syms))]\n    (analyze ctx expansion)))\n\n(defn expand-lazy-seq\n  [ctx expr]\n  (let [body (rest expr)]\n    (mark-eval-call\n     (list 'lazy-seq\n           (analyze ctx\n                    ;; expand-fn will take care of the analysis of the body\n                    (list 'fn [] (cons 'do body)))))))\n\n(defn expand-if\n  [ctx [_if & exprs :as expr]]\n  (case (count exprs)\n    (0 1) (throw-error-with-location \"Too few arguments to if\" expr)\n    (2 3) (mark-eval-call `(~'if ~@(analyze-children ctx exprs)))\n    (throw-error-with-location \"Too many arguments to if\" expr)))\n\n(defn expand-case\n  [ctx expr]\n  (let [v (analyze ctx (second expr))\n        clauses (nnext expr)\n        match-clauses (take-nth 2 clauses)\n        result-clauses (analyze-children ctx (take-nth 2 (rest clauses)))\n        default (when (odd? (count clauses))\n                  [:val (analyze ctx (last clauses))])\n        cases (interleave match-clauses result-clauses)\n        assoc-new (fn [m k v]\n                    (if-not (contains? m k)\n                      (assoc m k v)\n                      (throw-error-with-location (str \"Duplicate case test constant \" k)\n                                                 expr)))\n        case-map (loop [cases (seq cases)\n                        ret-map {}]\n                   (if cases\n                     (let [[k v & cases] cases]\n                       (if (list? k)\n                         (recur\n                          cases\n                          (reduce (fn [acc k]\n                                    (assoc-new acc k v))\n                                  ret-map\n                                  k))\n                         (recur\n                          cases\n                          (assoc-new ret-map k v))))\n                     ret-map))\n        ret (mark-eval-call (list 'case\n                                  {:case-map case-map\n                                   :case-val v\n                                   :case-default default}\n                                  default))]\n    (mark-eval-call ret)))\n\n(defn expand-try\n  [ctx [_try & body]]\n  (let [[body-exprs\n         catches\n         finally]\n        (loop [exprs #_[expr & exprs :as all-exprs] (seq body)\n               body-exprs []\n               catch-exprs []\n               finally-expr nil]\n          (if exprs\n            (let [expr (first exprs)\n                  exprs (next exprs)]\n              (cond (and (seq? expr) (= 'catch (first expr)))\n                    (recur exprs body-exprs (conj catch-exprs expr) finally-expr)\n                    (and (not exprs) (and (seq? expr) (= 'finally (first expr))))\n                    [body-exprs catch-exprs expr]\n                    :else\n                    ;; TODO: cannot add body expression when catch is not empty\n                    ;; TODO: can't have finally as non-last expression\n                    (recur exprs (conj body-exprs expr) catch-exprs finally-expr)))\n            [body-exprs catch-exprs finally-expr]))\n        body (analyze ctx (cons 'do body-exprs))\n        catches (mapv (fn [c]\n                        (let [[_ ex binding & body] c]\n                          (if-let [clazz (interop/resolve-class ctx ex)]\n                            {:class clazz\n                             :binding binding\n                             :body (analyze (assoc-in ctx [:bindings binding] nil)\n                                            (cons 'do body))}\n                            (throw-error-with-location (str \"Unable to resolve classname: \" ex) ex))))\n                      catches)\n        finally (when finally\n                  (analyze ctx (cons 'do (rest finally))))]\n    (with-meta\n      {:sci.impl/try\n       {:body body\n        :catches catches\n        :finally finally}}\n      {:sci.impl/op :try})))\n\n(defn expand-declare [ctx [_declare & names :as _expr]]\n  (swap! (:env ctx)\n         (fn [env]\n           (let [cnn (vars/current-ns-name)]\n             (update-in env [:namespaces cnn]\n                        (fn [current-ns]\n                          (reduce (fn [acc name]\n                                    (if (contains? acc name)\n                                      ;; declare does not override an existing\n                                      ;; var\n                                      acc\n                                      (assoc acc name\n                                             (doto (vars/->SciVar nil (symbol (str cnn)\n                                                                              (str name))\n                                                                  (assoc (meta name)\n                                                                         :name name\n                                                                         :ns @vars/current-ns\n                                                                         :file @vars/current-file))\n                                               (vars/unbind)))))\n                                  current-ns\n                                  names))))))\n  nil)\n\n(defn do-import [{:keys [:env] :as ctx} [_ & import-symbols-or-lists :as expr]]\n  (let [specs (map #(if (and (seq? %) (= 'quote (first %))) (second %) %)\n                   import-symbols-or-lists)]\n    (doseq [spec (reduce (fn [v spec]\n                           (if (symbol? spec)\n                             (conj v (name spec))\n                             (let [p (first spec) cs (rest spec)]\n                               (into v (map #(str p \".\" %) cs)))))\n                         [] specs)]\n      (let [fq-class-name (symbol spec)]\n        (when-not (interop/resolve-class ctx fq-class-name)\n          (throw-error-with-location (str \"Unable to resolve classname: \" fq-class-name) expr))\n        (let [last-dot (str/last-index-of spec \".\")\n              class-name (subs spec (inc last-dot) (count spec))\n              cnn (vars/current-ns-name)]\n          (swap! env assoc-in [:namespaces cnn :imports (symbol class-name)] fq-class-name))))))\n\n;;;; Interop\n\n(defn expand-dot [ctx [_dot instance-expr method-expr & args :as _expr]]\n  (let [[method-expr & args] (if (seq? method-expr) method-expr\n                                 (cons method-expr args))\n        instance-expr (analyze ctx instance-expr)\n        instance-expr (utils/vary-meta*\n                       instance-expr\n                       (fn [m]\n                         (if-let [t (:tag m)]\n                           (let [clazz (or (interop/resolve-class ctx t)\n                                           (throw-error-with-location\n                                            (str \"Unable to resolve classname: \" t) t))]\n                             (assoc m :tag-class clazz))\n                           m)))\n        method-expr (name method-expr)\n        args (analyze-children ctx args)\n        res #?(:clj (if (class? instance-expr)\n                      `(~(with-meta [instance-expr method-expr]\n                           {:sci.impl/op :static-access}) ~@args)\n                      `(~'. ~instance-expr ~method-expr ~args))\n               :cljs `(~'. ~instance-expr ~method-expr ~args))]\n    (mark-eval-call res)))\n\n(defn expand-dot**\n  \"Expands (. x method)\"\n  [ctx expr]\n  (when (< (count expr) 3)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx expr))\n\n(defn expand-dot*\n  \"Expands (.foo x)\"\n  [ctx [method-name obj & args :as expr]]\n  (when (< (count expr) 2)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx (list '. obj (cons (symbol (subs (name method-name) 1)) args))))\n\n(defn expand-new [ctx [_new class-sym & args]]\n  (if-let [#?(:clj {:keys [:class] :as _opts}\n              :cljs {:keys [:constructor] :as _opts}) (interop/resolve-class-opts ctx class-sym)]\n    (let [args (analyze-children ctx args)] ;; analyze args!\n      (mark-eval-call (list 'new #?(:clj class :cljs constructor) args)))\n    (throw-error-with-location (str \"Unable to resolve classname: \" class-sym) class-sym)))\n\n(defn expand-constructor [ctx [constructor-sym & args]]\n  (let [;; TODO:\n        ;; here it strips the namespace, which is correct in the case of\n        ;; js/Error. but not in clj\n        constructor-name (name constructor-sym)\n        class-sym (with-meta (symbol (subs constructor-name 0\n                                           (dec (count constructor-name))))\n                    (meta constructor-sym))]\n    (expand-new ctx (with-meta (list* 'new class-sym args)\n                      (meta constructor-sym)))))\n\n;;;; End interop\n\n;;;; Namespaces\n\n(defn analyze-ns-form [ctx [_ns ns-name & exprs]]\n  (when-not (symbol? ns-name)\n    (throw (new #?(:clj IllegalArgumentException\n                   :cljs js/Error)\n                (str \"Namespace name must be symbol, got: \" (pr-str ns-name)))))\n  (let [[docstring exprs]\n        (let [fexpr (first exprs)]\n          (if (string? fexpr)\n            [fexpr (next exprs)]\n            [nil exprs]))\n        ;; skip attr-map\n        [attr-map exprs]\n        (let [m (first exprs)]\n          (if (map? m)\n            [m (next exprs)]\n            [nil exprs]))\n        attr-map (if docstring\n                   (assoc attr-map :doc docstring)\n                   attr-map)]\n    (set-namespace! ctx ns-name attr-map)\n    (loop [exprs exprs\n           ret []]\n      (if exprs\n        (let [[k & args] (first exprs)]\n          (case k\n            (:require :use)\n            (recur (next exprs)\n                   (conj ret\n                         (mark-eval-call\n                          (list* (symbol (name k)) args))))\n            :import (do\n                      ;; imports are processed analysis time\n                      (do-import ctx `(~'import ~@args))\n                      (recur (next exprs) ret))\n            :refer-clojure (recur (next exprs)\n                                  (conj ret\n                                        (mark-eval-call\n                                         (list* 'refer 'clojure.core args))))\n            :gen-class ;; ignore\n            (recur (next exprs) ret)))\n        (mark-eval-call (list* 'do ret))))))\n\n;;;; End namespaces\n\n\n;;;; Vars\n\n(defn analyze-var [ctx [_ var-name]]\n  (resolve-symbol (assoc ctx :sci.impl/prevent-deref true) var-name))\n\n(defn analyze-set! [ctx [_ obj v]]\n  (let [obj (analyze ctx obj)\n        v (analyze ctx v)\n        obj (types/getVal obj)]\n    (mark-eval-call (list 'set! obj v))))\n\n;;;; End vars\n\n;;;; Macros\n\n(defn macro? [f]\n  (when-let [m (meta f)]\n    (or (:sci/macro m) ;; TODO: deprecate\n        (:macro m))))\n\n;;;; End macros\n\n(defn analyze-call [ctx expr]\n  (let [f (first expr)]\n    (if (symbol? f)\n      (let [;; in call position Clojure prioritizes special symbols over\n            ;; bindings\n            special-sym (get special-syms f)\n            _ (when special-sym (check-permission! ctx special-sym f))\n            f (or special-sym\n                  (resolve-symbol ctx f true))\n            f (if (and (vars/var? f)\n                       (or\n                        (vars/isMacro f)\n                        (-> f meta :sci.impl/built-in)))\n                @f f)]\n        (if (and (not (eval? f)) ;; the symbol is not a binding\n                 (or\n                  special-sym\n                  (contains? macros f)))\n          (case f\n            ;; we treat every subexpression of a top-level do as a separate\n            ;; analysis/interpretation unit so we hand this over to the\n            ;; interpreter again, which will invoke analysis + evaluation on\n            ;; every sub expression\n            do (mark-eval-call (cons 'do\n                                     (analyze-children ctx (rest expr))))\n            let (expand-let ctx expr)\n            (fn fn*) (expand-fn ctx expr false)\n            def (expand-def ctx expr)\n            ;; NOTE: defn / defmacro aren't implemented as normal macros yet\n            (defn defmacro) (let [ret (expand-defn ctx expr)]\n                              ret)\n            ;; TODO: implement as normal macro in namespaces.cljc\n            -> (expand-> ctx (rest expr))\n            ;; TODO: implement as normal macro in namespaces.cljc\n            as-> (expand-as-> ctx expr)\n            quote (do nil (second expr))\n            ;; TODO: implement as normal macro in namespaces.cljc\n            comment (expand-comment ctx expr)\n            loop (expand-loop ctx expr)\n            lazy-seq (expand-lazy-seq ctx expr)\n            for (let [res (expand-for ctx expr)]\n                  (if (:sci.impl/macroexpanding ctx)\n                    res\n                    (analyze ctx res)))\n            doseq (analyze ctx (expand-doseq ctx expr))\n            if (expand-if ctx expr)\n            case (expand-case ctx expr)\n            try (expand-try ctx expr)\n            declare (expand-declare ctx expr)\n            expand-dot* (expand-dot* ctx expr)\n            . (expand-dot** ctx expr)\n            expand-constructor (expand-constructor ctx expr)\n            new (expand-new ctx expr)\n            import (do-import ctx expr)\n            ns (analyze-ns-form ctx expr)\n            var (analyze-var ctx expr)\n            set! (analyze-set! ctx expr)\n            ;; macroexpand-1 (macroexpand-1 ctx expr)\n            ;; macroexpand (macroexpand ctx expr)\n            ;; else:\n            (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n          (try\n            (if (macro? f)\n              (let [needs-ctx? (kw-identical? :needs-ctx\n                                              (:sci.impl/op (meta f)))\n                    v (if needs-ctx?\n                        (apply f expr\n                               (:bindings ctx)\n                               ctx\n                               (rest expr))\n                        (apply f expr\n                               (:bindings ctx) (rest expr)))\n                    expanded (if (:sci.impl/macroexpanding ctx)\n                               v\n                               (analyze ctx v))]\n                expanded)\n              (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n            (catch #?(:clj Exception :cljs js/Error) e\n              (rethrow-with-location-of-node ctx e expr)))))\n      (let [ret (mark-eval-call (analyze-children ctx expr))]\n        ret))))\n\n(defn analyze\n  [ctx expr]\n  ;; (prn \"ana\" expr)\n  (let [ret (cond (constant? expr) expr ;; constants do not carry metadata\n                  (symbol? expr) (let [v (resolve-symbol ctx expr false)]\n                                   (cond (constant? v) v\n                                         ;; (fn? v) (utils/vary-meta* v dissoc :sci.impl/op)\n                                         (vars/var? v) (if (:const (meta v))\n                                                         @v (types/->EvalVar v))\n                                         :else (merge-meta v (meta expr))))\n                  :else\n                  (merge-meta\n                   (cond\n                     (map? expr)\n                     (-> (zipmap (analyze-children ctx (keys expr))\n                                 (analyze-children ctx (vals expr)))\n                         mark-eval)\n                     (or (vector? expr) (set? expr))\n                     (-> (into (empty expr) (analyze-children ctx expr))\n                         mark-eval)\n                     (and (seq? expr) (seq expr))\n                     (analyze-call ctx expr)\n                     :else expr)\n                   (select-keys (meta expr)\n                                [:line :column :tag])))]\n    ;; (prn \"ana\" expr '-> ret 'm-> (meta ret))\n    ret))\n\n;;;; Scratch\n\n(comment\n  )\n"]}