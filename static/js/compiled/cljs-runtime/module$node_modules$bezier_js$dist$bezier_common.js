shadow$provide.module$node_modules$bezier_js$dist$bezier_common=function(global,require,module,exports){function crt(v){return 0>v?-pow(-v,1/3):pow(v,1/3)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Bezier=void 0;const {abs,cos,sin,acos,atan2,sqrt,pow}=Math;global=Math.PI;const tau=2*global,quart=global/2,nMax=Number.MAX_SAFE_INTEGER||9007199254740991,nMin=Number.MIN_SAFE_INTEGER||-9007199254740991,ZERO={x:0,y:0,z:0},utils={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,
.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,
.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,derivativeFn){t=derivativeFn(t);derivativeFn=t.x*t.x+t.y*t.y;"undefined"!==typeof t.z&&(derivativeFn+=t.z*t.z);return sqrt(derivativeFn)},compute:function(t,
points,_3d){if(0===t)return points[0].t=0,points[0];const order=points.length-1;if(1===t)return points[order].t=1,points[order];const mt=1-t;var p=points;if(0===order)return points[0].t=t,points[0];if(1===order){var ret={x:mt*p[0].x+t*p[1].x,y:mt*p[0].y+t*p[1].y,t};_3d&&(ret.z=mt*p[0].z+t*p[1].z);return ret}if(4>order){let mt2=mt*mt,t2=t*t,b,c;points=0;2===order?(p=[p[0],p[1],p[2],ZERO],ret=mt2,b=mt*t*2,c=t2):3===order&&(ret=mt2*mt,b=mt2*t*3,c=mt*t2*3,points=t*t2);t={x:ret*p[0].x+b*p[1].x+c*p[2].x+
points*p[3].x,y:ret*p[0].y+b*p[1].y+c*p[2].y+points*p[3].y,t};_3d&&(t.z=ret*p[0].z+b*p[1].z+c*p[2].z+points*p[3].z);return t}for(_3d=JSON.parse(JSON.stringify(points));1<_3d.length;){for(p=0;p<_3d.length-1;p++)_3d[p]={x:_3d[p].x+(_3d[p+1].x-_3d[p].x)*t,y:_3d[p].y+(_3d[p+1].y-_3d[p].y)*t},"undefined"!==typeof _3d[p].z&&(_3d[p]=_3d[p].z+(_3d[p+1].z-_3d[p].z)*t);_3d.splice(_3d.length-1,1)}_3d[0].t=t;return _3d[0]},computeWithRatios:function(t,points,ratios,_3d){var mt=1-t;let f1=ratios[0],f2=ratios[1],
f3=ratios[2];ratios=ratios[3];f1*=mt;f2*=t;if(2===points.length)return mt=f1+f2,{x:(f1*points[0].x+f2*points[1].x)/mt,y:(f1*points[0].y+f2*points[1].y)/mt,z:_3d?(f1*points[0].z+f2*points[1].z)/mt:!1,t};f1*=mt;f2*=2*mt;f3*=t*t;if(3===points.length)return mt=f1+f2+f3,{x:(f1*points[0].x+f2*points[1].x+f3*points[2].x)/mt,y:(f1*points[0].y+f2*points[1].y+f3*points[2].y)/mt,z:_3d?(f1*points[0].z+f2*points[1].z+f3*points[2].z)/mt:!1,t};f1*=mt;f2*=1.5*mt;f3*=3*mt;ratios*=t*t*t;if(4===points.length)return mt=
f1+f2+f3+ratios,{x:(f1*points[0].x+f2*points[1].x+f3*points[2].x+ratios*points[3].x)/mt,y:(f1*points[0].y+f2*points[1].y+f3*points[2].y+ratios*points[3].y)/mt,z:_3d?(f1*points[0].z+f2*points[1].z+f3*points[2].z+ratios*points[3].z)/mt:!1,t}},derive:function(points,_3d){const dpoints=[];for(let p=points,d=p.length,c=d-1;1<d;d--,c--){points=[];for(let j=0,dpt;j<c;j++)dpt={x:c*(p[j+1].x-p[j].x),y:c*(p[j+1].y-p[j].y)},_3d&&(dpt.z=c*(p[j+1].z-p[j].z)),points.push(dpt);dpoints.push(points);p=points}return dpoints},
between:function(v,m,M){return m<=v&&v<=M||utils.approximately(v,m)||utils.approximately(v,M)},approximately:function(a,b,precision){return abs(a-b)<=(precision||1E-6)},length:function(derivativeFn){const len=utils.Tvalues.length;let sum=0;for(let i=0,t;i<len;i++)t=.5*utils.Tvalues[i]+.5,sum+=utils.Cvalues[i]*utils.arcfn(t,derivativeFn);return.5*sum},map:function(v,ds,de,ts,te){return ts+(v-ds)/(de-ds)*(te-ts)},lerp:function(r,v1,v2){const ret={x:v1.x+r*(v2.x-v1.x),y:v1.y+r*(v2.y-v1.y)};v1.z&&v2.z&&
(ret.z=v1.z+r*(v2.z-v1.z));return ret},pointToString:function(p){let s=p.x+"/"+p.y;"undefined"!==typeof p.z&&(s+="/"+p.z);return s},pointsToString:function(points){return"["+points.map(utils.pointToString).join(", ")+"]"},copy:function(obj){return JSON.parse(JSON.stringify(obj))},angle:function(o,v1,v2){const dx1=v1.x-o.x;v1=v1.y-o.y;const dx2=v2.x-o.x;o=v2.y-o.y;return atan2(dx1*o-v1*dx2,dx1*dx2+v1*o)},round:function(v,d){v=""+v;const pos=v.indexOf(".");return parseFloat(v.substring(0,pos+1+d))},
dist:function(p1,p2){const dx=p1.x-p2.x;p1=p1.y-p2.y;return sqrt(dx*dx+p1*p1)},closest:function(LUT,point){let mdist=pow(2,63),mpos,d;LUT.forEach(function(p,idx){d=utils.dist(point,p);d<mdist&&(mdist=d,mpos=idx)});return{mdist,mpos}},abcratio:function(t,n){if(2!==n&&3!==n)return!1;if("undefined"===typeof t)t=.5;else if(0===t||1===t)return t;t=pow(t,n)+pow(1-t,n);return abs((t-1)/t)},projectionratio:function(t,n){if(2!==n&&3!==n)return!1;if("undefined"===typeof t)t=.5;else if(0===t||1===t)return t;
const top=pow(1-t,n);t=pow(t,n)+top;return top/t},lli8:function(x1,y1,x2,y2,x3,y3,x4,y4){const d=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);return 0==d?!1:{x:((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/d,y:((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/d}},lli4:function(p1,p2,p3,p4){return utils.lli8(p1.x,p1.y,p2.x,p2.y,p3.x,p3.y,p4.x,p4.y)},lli:function(v1,v2){return utils.lli4(v1,v1.c,v2,v2.c)},makeline:function(p1,p2){const x1=p1.x;p1=p1.y;const x2=p2.x;p2=p2.y;const dx=(x2-x1)/3,dy=(p2-p1)/3;return new Bezier(x1,
p1,x1+dx,p1+dy,x1+2*dx,p1+2*dy,x2,p2)},findbbox:function(sections){let mx=nMax,my=nMax,MX=nMin,MY=nMin;sections.forEach(function(s){s=s.bbox();mx>s.x.min&&(mx=s.x.min);my>s.y.min&&(my=s.y.min);MX<s.x.max&&(MX=s.x.max);MY<s.y.max&&(MY=s.y.max)});return{x:{min:mx,mid:(mx+MX)/2,max:MX,size:MX-mx},y:{min:my,mid:(my+MY)/2,max:MY,size:MY-my}}},shapeintersections:function(s1,bbox1,s2,bbox2,curveIntersectionThreshold){if(!utils.bboxoverlap(bbox1,bbox2))return[];const intersections=[],a2=[s2.startcap,s2.forward,
s2.back,s2.endcap];[s1.startcap,s1.forward,s1.back,s1.endcap].forEach(function(l1){l1.virtual||a2.forEach(function(l2){if(!l2.virtual){var iss=l1.intersects(l2,curveIntersectionThreshold);0<iss.length&&(iss.c1=l1,iss.c2=l2,iss.s1=s1,iss.s2=s2,intersections.push(iss))}})});return intersections},makeshape:function(forward,back,curveIntersectionThreshold){var fpl=forward.points.length;const start=utils.makeline(back.points[back.points.length-1],forward.points[0]);fpl=utils.makeline(forward.points[fpl-
1],back.points[0]);const shape={startcap:start,forward,back,endcap:fpl,bbox:utils.findbbox([start,forward,back,fpl]),intersections:function(s2){return utils.shapeintersections(shape,shape.bbox,s2,s2.bbox,curveIntersectionThreshold)}};return shape},getminmax:function(curve,d,list){if(!list)return{min:0,max:0};let min=nMax,max=nMin;-1===list.indexOf(0)&&(list=[0].concat(list));-1===list.indexOf(1)&&list.push(1);for(let i=0,len=list.length;i<len;i++){var t=list[i];t=curve.get(t);t[d]<min&&(min=t[d]);
t[d]>max&&(max=t[d])}return{min,mid:(min+max)/2,max,size:max-min}},align:function(points,line){const tx=line.p1.x,ty=line.p1.y,a=-atan2(line.p2.y-ty,line.p2.x-tx);return points.map(function(v){return{x:(v.x-tx)*cos(a)-(v.y-ty)*sin(a),y:(v.x-tx)*sin(a)+(v.y-ty)*cos(a)}})},roots:function(points,line){line=line||{p1:{x:0,y:0},p2:{x:1,y:0}};var order=points.length-1;line=utils.align(points,line);points=function(t){return 0<=t&&1>=t};if(2===order){order=line[0].y;var b=line[1].y,c=line[2].y;line=order-
2*b+c;return 0!==line?(c=-sqrt(b*b-order*c),order=-order+b,[-(c+order)/line,-(-c+order)/line].filter(points)):b!==c&&0===line?[(2*b-c)/(2*b-2*c)].filter(points):[]}order=line[0].y;b=line[1].y;var pc=line[2].y;c=-order+3*b-3*pc+line[3].y;line=3*order-6*b+3*pc;pc=-3*order+3*b;if(utils.approximately(c,0)){if(utils.approximately(line,0))return utils.approximately(pc,0)?[]:[-order/pc].filter(points);order=sqrt(pc*pc-4*line*order);line*=2;return[(order-pc)/line,(-pc-order)/line].filter(points)}line/=c;
pc/=c;b=(3*pc-line*line)/3;const p3=b/3;order=(2*line*line*line-9*line*pc+order/c*27)/27;c=order/2;pc=c*c+p3*p3*p3;if(0>pc)return b=-b/3,b=sqrt(b*b*b),order=-order/(2*b),c=acos(-1>order?-1:1<order?1:order),pc=2*crt(b),order=pc*cos(c/3)-line/3,b=pc*cos((c+tau)/3)-line/3,line=pc*cos((c+2*tau)/3)-line/3,[order,b,line].filter(points);if(0===pc)return order=0>c?crt(-c):-crt(c),[2*order-line/3,-order-line/3].filter(points);b=sqrt(pc);order=crt(-c+b);b=crt(c+b);return[order-b-line/3].filter(points)},droots:function(p){if(3===
p.length){var a=p[0],b=p[1],c=p[2];p=a-2*b+c;return 0!==p?(c=-sqrt(b*b-a*c),a=-a+b,[-(c+a)/p,-(-c+a)/p]):b!==c&&0===p?[(2*b-c)/(2*(b-c))]:[]}return 2===p.length&&(a=p[0],b=p[1],a!==b)?[a/(a-b)]:[]},curvature:function(t,d1,d2,_3d,kOnly){let adk,dk;var k=utils.compute(t,d1);var num=utils.compute(t,d2);var dnm=k.x*k.x+k.y*k.y;_3d?(num=sqrt(pow(k.y*num.z-num.y*k.z,2)+pow(k.z*num.x-num.z*k.x,2)+pow(k.x*num.y-num.x*k.y,2)),dnm=pow(dnm+k.z*k.z,1.5)):(num=k.x*num.y-k.y*num.x,dnm=pow(dnm,1.5));if(0===num||
0===dnm)return{k:0,r:0};k=num/dnm;num=dnm/num;kOnly||(kOnly=utils.curvature(t-.001,d1,d2,_3d,!0).k,t=utils.curvature(t+.001,d1,d2,_3d,!0).k,dk=(t-k+(k-kOnly))/2,adk=(abs(t-k)+abs(k-kOnly))/2);return{k,r:num,dk,adk}},inflections:function(points){if(4>points.length)return[];points=utils.align(points,{p1:points[0],p2:points.slice(-1)[0]});var a=points[2].x*points[1].y,b=points[3].x*points[1].y;const c=points[1].x*points[2].y;points=18*(-3*a+2*b+3*c-points[3].x*points[2].y);b=18*(3*a-b-3*c);a=18*(c-a);
if(utils.approximately(points,0))return!utils.approximately(b,0)&&(points=-a/b,0<=points&&1>=points)?[points]:[];a=Math.sqrt(b*b-4*points*a);points*=2;return utils.approximately(points,0)?[]:[(a-b)/points,-(b+a)/points].filter(function(r){return 0<=r&&1>=r})},bboxoverlap:function(b1,b2){const dims=["x","y"],len=dims.length;for(let i=0,dim,l,t,d;i<len;i++)if(dim=dims[i],l=b1[dim].mid,t=b2[dim].mid,d=(b1[dim].size+b2[dim].size)/2,abs(l-t)>=d)return!1;return!0},expandbox:function(bbox,_bbox){_bbox.x.min<
bbox.x.min&&(bbox.x.min=_bbox.x.min);_bbox.y.min<bbox.y.min&&(bbox.y.min=_bbox.y.min);_bbox.z&&_bbox.z.min<bbox.z.min&&(bbox.z.min=_bbox.z.min);_bbox.x.max>bbox.x.max&&(bbox.x.max=_bbox.x.max);_bbox.y.max>bbox.y.max&&(bbox.y.max=_bbox.y.max);_bbox.z&&_bbox.z.max>bbox.z.max&&(bbox.z.max=_bbox.z.max);bbox.x.mid=(bbox.x.min+bbox.x.max)/2;bbox.y.mid=(bbox.y.min+bbox.y.max)/2;bbox.z&&(bbox.z.mid=(bbox.z.min+bbox.z.max)/2);bbox.x.size=bbox.x.max-bbox.x.min;bbox.y.size=bbox.y.max-bbox.y.min;bbox.z&&(bbox.z.size=
bbox.z.max-bbox.z.min)},pairiteration:function(c1,c2,curveIntersectionThreshold){const c1b=c1.bbox(),c2b=c2.bbox(),threshold=curveIntersectionThreshold||.5;if(c1b.x.size+c1b.y.size<threshold&&c2b.x.size+c2b.y.size<threshold)return[(1E5*(c1._t1+c1._t2)/2|0)/1E5+"/"+(1E5*(c2._t1+c2._t2)/2|0)/1E5];c1=c1.split(.5);c2=c2.split(.5);c2=[{left:c1.left,right:c2.left},{left:c1.left,right:c2.right},{left:c1.right,right:c2.right},{left:c1.right,right:c2.left}];c2=c2.filter(function(pair){return utils.bboxoverlap(pair.left.bbox(),
pair.right.bbox())});let results=[];if(0===c2.length)return results;c2.forEach(function(pair){results=results.concat(utils.pairiteration(pair.left,pair.right,threshold))});return results=results.filter(function(v,i){return results.indexOf(v)===i})},getccenter:function(p1,p2,p3){var dx1=p2.x-p1.x,dy1=p2.y-p1.y,dx2=p3.x-p2.x,dy2=p3.y-p2.y,dx1p=dx1*cos(quart)-dy1*sin(quart);dx1=dx1*sin(quart)+dy1*cos(quart);dy1=dx2*cos(quart)-dy2*sin(quart);dx2=dx2*sin(quart)+dy2*cos(quart);dy2=(p1.x+p2.x)/2;const my1=
(p1.y+p2.y)/2,mx2=(p2.x+p3.x)/2,my2=(p2.y+p3.y)/2;dx1p=utils.lli8(dy2,my1,dy2+dx1p,my1+dx1,mx2,my2,mx2+dy1,my2+dx2);dx1=utils.dist(dx1p,p1);p1=atan2(p1.y-dx1p.y,p1.x-dx1p.x);p2=atan2(p2.y-dx1p.y,p2.x-dx1p.x);p3=atan2(p3.y-dx1p.y,p3.x-dx1p.x);if(p1<p3){if(p1>p2||p2>p3)p1+=tau;p1>p3&&(p2=p3,p3=p1,p1=p2)}else p3<p2&&p2<p1?(p2=p3,p3=p1,p1=p2):p3+=tau;dx1p.s=p1;dx1p.e=p3;dx1p.r=dx1;return dx1p},numberSort:function(a,b){return a-b}};class PolyBezier{constructor(curves){this.curves=[];this._3d=!1;curves&&
(this.curves=curves,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(curve){return utils.pointsToString(curve.points)}).join(", ")+"]"}addCurve(curve){this.curves.push(curve);this._3d=this._3d||curve._3d}length(){return this.curves.map(function(v){return v.length()}).reduce(function(a,b){return a+b})}curve(idx){return this.curves[idx]}bbox(){const c=this.curves;for(var bbox=c[0].bbox(),i=1;i<c.length;i++)utils.expandbox(bbox,c[i].bbox());
return bbox}offset(d){const offset=[];this.curves.forEach(function(v){offset.push(...v.offset(d))});return new PolyBezier(offset)}}const {abs:abs$1,min:min$jscomp$0,max:max$jscomp$0,cos:cos$1,sin:sin$1,acos:acos$1,sqrt:sqrt$1}=Math,pi$1=Math.PI;class Bezier{constructor(coords){var args=coords&&coords.forEach?coords:Array.from(arguments).slice(),coordlen=!1;if("object"===typeof args[0]){coordlen=args.length;const newargs=[];args.forEach(function(point){["x","y","z"].forEach(function(d){"undefined"!==
typeof point[d]&&newargs.push(point[d])})});args=newargs}var higher=!1,len=args.length;if(coordlen){if(4<coordlen){if(1!==arguments.length)throw Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");higher=!0}}else if(6!==len&&8!==len&&9!==len&&12!==len&&1!==arguments.length)throw Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");coordlen=this._3d=!higher&&(9===len||12===len)||coords&&coords[0]&&"undefined"!==typeof coords[0].z;higher=this.points=
[];for(let idx=0,step=coordlen?3:2;idx<len;idx+=step){var point$jscomp$0={x:args[idx],y:args[idx+1]};coordlen&&(point$jscomp$0.z=args[idx+2]);higher.push(point$jscomp$0)}args=this.order=higher.length-1;len=this.dims=["x","y"];coordlen&&len.push("z");this.dimlen=len.length;this._linear=!utils.align(higher,{p1:higher[0],p2:higher[args]}).some(p=>1E-4<abs$1(p.y));this._lut=[];this._t1=0;this._t2=1;this.update()}static quadraticFromPoints(p1,p2,p3,t){"undefined"===typeof t&&(t=.5);if(0===t)return new Bezier(p2,
p2,p3);if(1===t)return new Bezier(p1,p2,p2);p2=Bezier.getABC(2,p1,p2,p3,t);return new Bezier(p1,p2.A,p3)}static cubicFromPoints(S,B,E,t,d1){"undefined"===typeof t&&(t=.5);var abc=Bezier.getABC(3,S,B,E,t);"undefined"===typeof d1&&(d1=utils.dist(B,abc.C));const d2=d1*(1-t)/t;var selen=utils.dist(S,E);const lx=(E.x-S.x)/selen;selen=(E.y-S.y)/selen;abc=abc.A;return new Bezier(S,{x:S.x+(abc.x+(B.x-d1*lx-abc.x)/(1-t)-S.x)/t,y:S.y+(abc.y+(B.y-d1*selen-abc.y)/(1-t)-S.y)/t},{x:E.x+(abc.x+(B.x+d2*lx-abc.x)/
t-E.x)/(1-t),y:E.y+(abc.y+(B.y+d2*selen-abc.y)/t-E.y)/(1-t)},E)}static getUtils(){return utils}getUtils(){return Bezier.getUtils()}static get PolyBezier(){return PolyBezier}valueOf(){return this.toString()}toString(){return utils.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const p=this.points,s=["M",p[0].x,p[0].y,2===this.order?"Q":"C"];for(let i=1,last=p.length;i<last;i++)s.push(p[i].x),s.push(p[i].y);return s.join(" ")}setRatios(ratios){if(ratios.length!==this.points.length)throw Error("incorrect number of ratio values");
this.ratios=ratios;this._lut=[]}verify(){const print=this.coordDigest();print!==this._print&&(this._print=print,this.update())}coordDigest(){return this.points.map(function(c,pos){return""+pos+c.x+c.y+(c.z?c.z:0)}).join("")}update(){this._lut=[];this.dpoints=utils.derive(this.points,this._3d);this.computedirection()}computedirection(){const points=this.points;this.clockwise=0<utils.angle(points[0],points[this.order],points[1])}length(){return utils.length(this.derivative.bind(this))}static getABC(order=
2,S,B,E,t=.5){var u=utils.projectionratio(t,order);const um=1-u;u={x:u*S.x+um*E.x,y:u*S.y+um*E.y};order=utils.abcratio(t,order);return{A:{x:B.x+(B.x-u.x)/order,y:B.y+(B.y-u.y)/order},B,C:u,S,E}}getABC(t,B){B=B||this.get(t);return Bezier.getABC(this.order,this.points[0],B,this.points[this.order],t)}getLUT(steps){this.verify();steps=steps||100;if(this._lut.length===steps)return this._lut;this._lut=[];steps--;for(let i=0,p,t;i<steps;i++)t=i/(steps-1),p=this.compute(t),p.t=t,this._lut.push(p);return this._lut}on(point,
error){error=error||5;const lut=this.getLUT(),hits=[];for(let i=0,c;i<lut.length;i++)c=lut[i],utils.dist(c,point)<error&&hits.push(c);return hits.length?t/=hits.length:!1}project(point){var LUT=this.getLUT(),l=LUT.length-1,closest=utils.closest(LUT,point),mpos=closest.mpos;LUT=(mpos+1)/l;const step=.1/l;closest=closest.mdist;mpos=l=(mpos-1)/l;for(closest+=1;l<LUT+step;l+=step){var p=this.compute(l);p=utils.dist(point,p);p<closest&&(closest=p,mpos=l)}mpos=0>mpos?0:1<mpos?1:mpos;p=this.compute(mpos);
p.t=mpos;p.d=closest;return p}get(t){return this.compute(t)}point(idx){return this.points[idx]}compute(t){return this.ratios?utils.computeWithRatios(t,this.points,this.ratios,this._3d):utils.compute(t,this.points,this._3d,this.ratios)}raise(){const p=this.points,np=[p[0]],k=p.length;for(let i=1,pi,pim;i<k;i++)pi=p[i],pim=p[i-1],np[i]={x:(k-i)/k*pi.x+i/k*pim.x,y:(k-i)/k*pi.y+i/k*pim.y};np[k]=p[k-1];return new Bezier(np)}derivative(t){return utils.compute(t,this.dpoints[0])}dderivative(t){return utils.compute(t,
this.dpoints[1])}align(){let p=this.points;return new Bezier(utils.align(p,{p1:p[0],p2:p[p.length-1]}))}curvature(t){return utils.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return utils.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){t=this.derivative(t);const q=sqrt$1(t.x*t.x+t.y*t.y);return{x:-t.y/q,y:t.x/q}}__normal3(t){const r1=this.derivative(t);t=this.derivative(t+.01);var q1=sqrt$1(r1.x*r1.x+r1.y*r1.y+r1.z*r1.z),q2=
sqrt$1(t.x*t.x+t.y*t.y+t.z*t.z);r1.x/=q1;r1.y/=q1;r1.z/=q1;t.x/=q2;t.y/=q2;t.z/=q2;q1=t.y*r1.z-t.z*r1.y;q2=t.z*r1.x-t.x*r1.z;t=t.x*r1.y-t.y*r1.x;const m=sqrt$1(q1*q1+q2*q2+t*t);q1/=m;q2/=m;t/=m;t=[q1*q1,q1*q2-t,q1*t+q2,q1*q2+t,q2*q2,q2*t-q1,q1*t-q2,q2*t+q1,t*t];return{x:t[0]*r1.x+t[1]*r1.y+t[2]*r1.z,y:t[3]*r1.x+t[4]*r1.y+t[5]*r1.z,z:t[6]*r1.x+t[7]*r1.y+t[8]*r1.z}}hull(t){let p=this.points,_p,q=[],idx=0;q[idx++]=p[0];q[idx++]=p[1];q[idx++]=p[2];for(3===this.order&&(q[idx++]=p[3]);1<p.length;){_p=[];
for(let i=0,pt,l=p.length-1;i<l;i++)pt=utils.lerp(t,p[i],p[i+1]),q[idx++]=pt,_p.push(pt);p=_p}return q}split(t1,t2){if(0===t1&&t2)return this.split(t2).left;if(1===t2)return this.split(t1).right;var q=this.hull(t1);q={left:2===this.order?new Bezier([q[0],q[3],q[5]]):new Bezier([q[0],q[4],q[7],q[9]]),right:2===this.order?new Bezier([q[5],q[4],q[2]]):new Bezier([q[9],q[8],q[6],q[3]]),span:q};q.left._t1=utils.map(0,0,1,this._t1,this._t2);q.left._t2=utils.map(t1,0,1,this._t1,this._t2);q.right._t1=utils.map(t1,
0,1,this._t1,this._t2);q.right._t2=utils.map(1,0,1,this._t1,this._t2);if(!t2)return q;t2=utils.map(t2,t1,1,0,1);return q.right.split(t2).left}extrema(){const result={};let roots=[];this.dims.forEach(function(dim){let mfn=function(v){return v[dim]},p=this.dpoints[0].map(mfn);result[dim]=utils.droots(p);3===this.order&&(p=this.dpoints[1].map(mfn),result[dim]=result[dim].concat(utils.droots(p)));result[dim]=result[dim].filter(function(t){return 0<=t&&1>=t});roots=roots.concat(result[dim].sort(utils.numberSort))}.bind(this));
result.values=roots.sort(utils.numberSort).filter(function(v,idx){return roots.indexOf(v)===idx});return result}bbox(){const extrema=this.extrema(),result={};this.dims.forEach(function(d){result[d]=utils.getminmax(this,d,extrema[d])}.bind(this));return result}overlaps(curve){const lbbox=this.bbox();curve=curve.bbox();return utils.bboxoverlap(lbbox,curve)}offset(t,d){if("undefined"!==typeof d){const c=this.get(t),n=this.normal(t),ret={c,n,x:c.x+n.x*d,y:c.y+n.y*d};this._3d&&(ret.z=c.z+n.z*d);return ret}if(this._linear){const nv=
this.normal(0);d=this.points.map(function(p){const ret={x:p.x+t*nv.x,y:p.y+t*nv.y};p.z&&nv.z&&(ret.z=p.z+t*nv.z);return ret});return[new Bezier(d)]}return this.reduce().map(function(s){return s._linear?s.offset(t)[0]:s.scale(t)})}simple(){if(3===this.order){var a1=utils.angle(this.points[0],this.points[3],this.points[1]),a2=utils.angle(this.points[0],this.points[3],this.points[2]);if(0<a1&&0>a2||0>a1&&0<a2)return!1}a1=this.normal(0);a2=this.normal(1);let s=a1.x*a2.x+a1.y*a2.y;this._3d&&(s+=a1.z*a2.z);
return abs$1(acos$1(s))<pi$1/3}reduce(){let i,t1=0,t2=0,segment,pass1=[],pass2=[],extrema=this.extrema().values;-1===extrema.indexOf(0)&&(extrema=[0].concat(extrema));-1===extrema.indexOf(1)&&extrema.push(1);t1=extrema[0];for(i=1;i<extrema.length;i++)t2=extrema[i],segment=this.split(t1,t2),segment._t1=t1,segment._t2=t2,pass1.push(segment),t1=t2;pass1.forEach(function(p1){for(t2=t1=0;1>=t2;)for(t2=t1+.01;1.01>=t2;t2+=.01)if(segment=p1.split(t1,t2),!segment.simple()){t2-=.01;if(.01>abs$1(t1-t2))return[];
segment=p1.split(t1,t2);segment._t1=utils.map(t1,0,1,p1._t1,p1._t2);segment._t2=utils.map(t2,0,1,p1._t1,p1._t2);pass2.push(segment);t1=t2;break}1>t1&&(segment=p1.split(t1,1),segment._t1=utils.map(t1,0,1,p1._t1,p1._t2),segment._t2=p1._t2,pass2.push(segment))});return pass2}scale(d$jscomp$0){const order=this.order;let distanceFn=!1;"function"===typeof d$jscomp$0&&(distanceFn=d$jscomp$0);if(distanceFn&&2===order)return this.raise().scale(distanceFn);const clockwise=this.clockwise,r1=distanceFn?distanceFn(0):
d$jscomp$0,r2=distanceFn?distanceFn(1):d$jscomp$0,v=[this.offset(0,10),this.offset(1,10)],points=this.points,np=[],o=utils.lli4(v[0],v[0].c,v[1],v[1].c);if(!o)throw Error("cannot scale this curve. Try reducing it first.");[0,1].forEach(function(t){const p=np[t*order]=utils.copy(points[t*order]);p.x+=(t?r2:r1)*v[t].n.x;p.y+=(t?r2:r1)*v[t].n.y});if(!distanceFn)return[0,1].forEach(t=>{if(2!==order||!t){var p=np[t*order],d=this.derivative(t);np[t+1]=utils.lli4(p,{x:p.x+d.x,y:p.y+d.y},o,points[t+1])}}),
new Bezier(np);[0,1].forEach(function(t){if(2!==order||!t){var p=points[t+1],JSCompiler_object_inline_x_2598=p.x-o.x,JSCompiler_object_inline_y_2599=p.y-o.y,rc=distanceFn?distanceFn((t+1)/order):d$jscomp$0;distanceFn&&!clockwise&&(rc=-rc);var m=sqrt$1(JSCompiler_object_inline_x_2598*JSCompiler_object_inline_x_2598+JSCompiler_object_inline_y_2599*JSCompiler_object_inline_y_2599);np[t+1]={x:p.x+JSCompiler_object_inline_x_2598/m*rc,y:p.y+JSCompiler_object_inline_y_2599/m*rc}}});return new Bezier(np)}outline(d1,
d2,d3,d4){function linearDistanceFunction(s,e,tlen,alen,slen){return function(v){const d=e-s;return utils.map(v,0,1,s+alen/tlen*d,s+(alen+slen)/tlen*d)}}d2="undefined"===typeof d2?d1:d2;var reduced=this.reduce(),len=reduced.length;const fcurves=[];let bcurves=[],p,alen=0,tlen=this.length();const graduated="undefined"!==typeof d3&&"undefined"!==typeof d4;reduced.forEach(function(segment){const slen=segment.length();graduated?(fcurves.push(segment.scale(linearDistanceFunction(d1,d3,tlen,alen,slen))),
bcurves.push(segment.scale(linearDistanceFunction(-d2,-d4,tlen,alen,slen)))):(fcurves.push(segment.scale(d1)),bcurves.push(segment.scale(-d2)));alen+=slen});bcurves=bcurves.map(function(s){p=s.points;s.points=p[3]?[p[3],p[2],p[1],p[0]]:[p[2],p[1],p[0]];return s}).reverse();reduced=fcurves[len-1].points[fcurves[len-1].points.length-1];const be=bcurves[0].points[0];len=utils.makeline(bcurves[len-1].points[bcurves[len-1].points.length-1],fcurves[0].points[0]);reduced=utils.makeline(reduced,be);len=[len].concat(fcurves).concat([reduced]).concat(bcurves);
return new PolyBezier(len)}outlineshapes(d1,d2,curveIntersectionThreshold){d1=this.outline(d1,d2||d1).curves;d2=[];for(let i=1,len=d1.length;i<len/2;i++){const shape=utils.makeshape(d1[i],d1[len-i],curveIntersectionThreshold);shape.startcap.virtual=1<i;shape.endcap.virtual=i<len/2-1;d2.push(shape)}return d2}intersects(curve,curveIntersectionThreshold){if(!curve)return this.selfintersects(curveIntersectionThreshold);if(curve.p1&&curve.p2)return this.lineIntersects(curve);curve instanceof Bezier&&(curve=
curve.reduce());return this.curveintersects(this.reduce(),curve,curveIntersectionThreshold)}lineIntersects(line){const mx=min$jscomp$0(line.p1.x,line.p2.x),my=min$jscomp$0(line.p1.y,line.p2.y),MX=max$jscomp$0(line.p1.x,line.p2.x),MY=max$jscomp$0(line.p1.y,line.p2.y);return utils.roots(this.points,line).filter(t=>{t=this.get(t);return utils.between(t.x,mx,MX)&&utils.between(t.y,my,MY)})}selfintersects(curveIntersectionThreshold){const reduced=this.reduce(),len=reduced.length-2,results=[];for(let i=
0,result,left,right;i<len;i++)left=reduced.slice(i,i+1),right=reduced.slice(i+2),result=this.curveintersects(left,right,curveIntersectionThreshold),results.push(...result);return results}curveintersects(c1,c2,curveIntersectionThreshold){const pairs=[];c1.forEach(function(l){c2.forEach(function(r){l.overlaps(r)&&pairs.push({left:l,right:r})})});let intersections=[];pairs.forEach(function(pair){pair=utils.pairiteration(pair.left,pair.right,curveIntersectionThreshold);0<pair.length&&(intersections=intersections.concat(pair))});
return intersections}arcs(errorThreshold){return this._iterate(errorThreshold||.5,[])}_error(pc,np1,s,e){const q=(e-s)/4;s=this.get(s+q);e=this.get(e-q);np1=utils.dist(pc,np1);s=utils.dist(pc,s);pc=utils.dist(pc,e);return abs$1(s-np1)+abs$1(pc-np1)}_iterate(errorThreshold,circles){var t_s=0;let t_e,safety;do{safety=0;t_e=1;let np1=this.get(t_s);var np2=void 0,np3=void 0;let prev_arc;np3=!1;var prev_good=void 0;let t_m,prev_e=1;do if(prev_good=np3,prev_arc=np2,t_m=(t_s+t_e)/2,np2=this.get(t_m),np3=
this.get(t_e),np2=utils.getccenter(np1,np2,np3),np2.interval={start:t_s,end:t_e},np3=this._error(np2,np1,t_s,t_e)<=errorThreshold,(prev_good=prev_good&&!np3)||(prev_e=t_e),np3){if(1<=t_e){np2.interval.end=prev_e=1;prev_arc=np2;1<t_e&&(t_s={x:np2.x+np2.r*cos$1(np2.e),y:np2.y+np2.r*sin$1(np2.e)},np2.e+=utils.angle({x:np2.x,y:np2.y},t_s,this.get(1)));break}t_e+=(t_e-t_s)/2}else t_e=t_m;while(!prev_good&&100>safety++);if(100<=safety)break;prev_arc=prev_arc?prev_arc:np2;circles.push(prev_arc);t_s=prev_e}while(1>
t_e);return circles}}exports.Bezier=Bezier}
//# sourceMappingURL=module$node_modules$bezier_js$dist$bezier_common.js.map
