{
"version":3,
"file":"module$node_modules$$sentry$utils$dist$promisebuffer.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAe,oDAAf,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACjHC,MAAA,CAAOC,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACA,KAAIC,QAAUN,OAAA,CAAQ,8CAAR,CAAd,CACIO,cAAgBP,OAAA,CAAQ,oDAAR,CAEhBQ,OAAAA,CAA+B,QAAS,EAAG,CAC3CA,QAASA,cAAa,CAACC,MAAD,CAAS,CAC3B,IAAA,CAAKA,MAAL,CAAcA,MAEd,KAAA,CAAKC,OAAL,CAAe,EAHY,CAQ/BF,aAAA,CAAcG,SAAd,CAAwBC,OAAxB,CAAkCC,QAAS,EAAG,CAC1C,MAAuBC,KAAAA,EAAvB,GAAO,IAAP,CAAYL,MAAZ,EAAoC,IAAA,CAAKM,MAAL,EAApC,CAAoD,IAApD,CAAyDN,MADf,CAS9CD,cAAA,CAAcG,SAAd,CAAwBK,GAAxB;AAA8BC,QAAS,CAACC,IAAD,CAAO,CAC1C,IAAIC,MAAQ,IACZ,IAAI,CAAC,IAAA,CAAKP,OAAL,EAAL,CACI,MAAOL,cAAA,CAAca,WAAd,CAA0BC,MAA1B,CAAiC,IAAIf,OAAJ,CAAYgB,WAAZ,CAAwB,iDAAxB,CAAjC,CAEwB,GAAnC,GAAI,IAAA,CAAKZ,OAAL,CAAaa,OAAb,CAAqBL,IAArB,CAAJ,EACI,IAAA,CAAKR,OAAL,CAAac,IAAb,CAAkBN,IAAlB,CAEJA,KAAA,CACKO,IADL,CACU,QAAS,EAAG,CAAE,MAAON,MAAA,CAAMO,MAAN,CAAaR,IAAb,CAAT,CADtB,CAAA,CAEKO,IAFL,CAEU,IAFV,CAEgB,QAAS,EAAG,CACxB,MAAON,MAAA,CAAMO,MAAN,CAAaR,IAAb,CAAA,CAAmBO,IAAnB,CAAwB,IAAxB,CAA8B,QAAS,EAAG,EAA1C,CADiB,CAF5B,CAQA,OAAOP,KAhBmC,CAwB9CV,cAAA,CAAcG,SAAd,CAAwBe,MAAxB,CAAiCC,QAAS,CAACT,IAAD,CAAO,CAE7C,MADkB,KAAA,CAAKR,OAAL,CAAakB,MAAb,CAAoB,IAAA,CAAKlB,OAAL,CAAaa,OAAb,CAAqBL,IAArB,CAApB,CAAgD,CAAhD,CAAAW,CAAmD,CAAnDA,CAD2B,CAOjDrB,cAAA,CAAcG,SAAd,CAAwBI,MAAxB,CAAiCe,QAAS,EAAG,CACzC,MAAO,KAAP,CAAYpB,OAAZ,CAAoBK,MADqB,CAS7CP;aAAA,CAAcG,SAAd,CAAwBoB,KAAxB,CAAgCC,QAAS,CAACC,OAAD,CAAU,CAC/C,IAAId,MAAQ,IACZ,OAAO,KAAIZ,aAAJ,CAAkBa,WAAlB,CAA8B,QAAS,CAACc,OAAD,CAAU,CACpD,IAAIC,mBAAqBC,UAAA,CAAW,QAAS,EAAG,CACxCH,OAAJ,EAAyB,CAAzB,CAAeA,OAAf,EACIC,OAAA,CAAQ,CAAA,CAAR,CAFwC,CAAvB,CAItBD,OAJsB,CAKzB1B,cAAA,CAAca,WAAd,CAA0BiB,GAA1B,CAA8BlB,KAA9B,CAAoCT,OAApC,CAAA,CACKe,IADL,CACU,QAAS,EAAG,CAClBa,YAAA,CAAaH,kBAAb,CACAD,QAAA,CAAQ,CAAA,CAAR,CAFkB,CADtB,CAAA,CAKKT,IALL,CAKU,IALV,CAKgB,QAAS,EAAG,CACxBS,OAAA,CAAQ,CAAA,CAAR,CADwB,CAL5B,CANoD,CAAjD,CAFwC,CAkBnD,OAAO1B,cA5EoC,CAAZ,EA8EnCN,QAAA,CAAQM,aAAR,CAAwBA,MAnFyF;",
"sources":["node_modules/@sentry/utils/dist/promisebuffer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$sentry$utils$dist$promisebuffer\"] = function(global,require,module,exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar error_1 = require(\"./error\");\nvar syncpromise_1 = require(\"./syncpromise\");\n/** A simple queue that holds promises. */\nvar PromiseBuffer = /** @class */ (function () {\n    function PromiseBuffer(_limit) {\n        this._limit = _limit;\n        /** Internal set of queued Promises */\n        this._buffer = [];\n    }\n    /**\n     * Says if the buffer is ready to take more requests\n     */\n    PromiseBuffer.prototype.isReady = function () {\n        return this._limit === undefined || this.length() < this._limit;\n    };\n    /**\n     * Add a promise to the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns The original promise.\n     */\n    PromiseBuffer.prototype.add = function (task) {\n        var _this = this;\n        if (!this.isReady()) {\n            return syncpromise_1.SyncPromise.reject(new error_1.SentryError('Not adding Promise due to buffer limit reached.'));\n        }\n        if (this._buffer.indexOf(task) === -1) {\n            this._buffer.push(task);\n        }\n        task\n            .then(function () { return _this.remove(task); })\n            .then(null, function () {\n            return _this.remove(task).then(null, function () {\n                // We have to add this catch here otherwise we have an unhandledPromiseRejection\n                // because it's a new Promise chain.\n            });\n        });\n        return task;\n    };\n    /**\n     * Remove a promise to the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    PromiseBuffer.prototype.remove = function (task) {\n        var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];\n        return removedTask;\n    };\n    /**\n     * This function returns the number of unresolved promises in the queue.\n     */\n    PromiseBuffer.prototype.length = function () {\n        return this._buffer.length;\n    };\n    /**\n     * This will drain the whole queue, returns true if queue is empty or drained.\n     * If timeout is provided and the queue takes longer to drain, the promise still resolves but with false.\n     *\n     * @param timeout Number in ms to wait until it resolves with false.\n     */\n    PromiseBuffer.prototype.drain = function (timeout) {\n        var _this = this;\n        return new syncpromise_1.SyncPromise(function (resolve) {\n            var capturedSetTimeout = setTimeout(function () {\n                if (timeout && timeout > 0) {\n                    resolve(false);\n                }\n            }, timeout);\n            syncpromise_1.SyncPromise.all(_this._buffer)\n                .then(function () {\n                clearTimeout(capturedSetTimeout);\n                resolve(true);\n            })\n                .then(null, function () {\n                resolve(true);\n            });\n        });\n    };\n    return PromiseBuffer;\n}());\nexports.PromiseBuffer = PromiseBuffer;\n//# sourceMappingURL=promisebuffer.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","error_1","syncpromise_1","PromiseBuffer","_limit","_buffer","prototype","isReady","PromiseBuffer.prototype.isReady","undefined","length","add","PromiseBuffer.prototype.add","task","_this","SyncPromise","reject","SentryError","indexOf","push","then","remove","PromiseBuffer.prototype.remove","splice","removedTask","PromiseBuffer.prototype.length","drain","PromiseBuffer.prototype.drain","timeout","resolve","capturedSetTimeout","setTimeout","all","clearTimeout"]
}
