{"version":3,"sources":["day8/re_frame/forward_events_fx.cljs"],"mappings":";AAIA;;;;;;;AAAA,AAAMA,AAMHC;AANH,AAOE,AAAMA;AAAN,AACE,AAAM,AAACC,AAAID;AAAeA;;AAA1B,AACM,AAAAE,AAAUF;AAAe,AAAAG;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAME;AAAN,AAAAD,AAAAD,AAAA,AAAA,AAAeG;AAAf,AACE,AAACC,AAAER,AAAcM;;;AAFlD,AAGM,AAACG,AAAMT;AAAe,AAAKU;AAAL,AACE,AAACF,AAAER,AAAcU;;;AAJ/C,AAKY,AACE,AAAA,AAAA,AAACC,AAAQ,AAAA,AAAK,AAACC,AAAOZ,AAEJA;;;;;;AATlC;;;AAYF,AAAA,AAACa,AAEC,AAAMC,AAAkB,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAAA,AAAUK;AAAV,AAAAD,AAAAJ,AAAA,AAAmBM;AAAnB,AAAAF,AAAAJ,AAAA,AAA8BO;AAA9B,AAAAH,AAAAJ,AAAA,AAAuCQ;AAAvC,AAAAJ,AAAAJ,AAAA,AAA8CS;AAA9C,AACE,AAAMlB,AAAE,AAAA,AAAA,AAAA,AAAA,AAAAmB,AAAA,AAAA,AAAA,AAAA,AAAQ,AAACC,AAAKN,AAAG,AAAA,AAA6FA;AAChHd,AAAE,AAAA,AAAA,AAAA,AAAA,AAAAmB,AAAA,AAAA,AAAA,AAAA,AAAQ,AAAI,AAAA,AAAA,AAAClB,AAAiB,AAAA,AAAIa,AAAEO,AAAKC,AAC7B,AAAA,AAAA,AAAA,AAAA,AAACrB,AAAoC,AAAA,AAAIa,AAAEO,AAAKC,AAAO,AAAA,AAA0E,AAAA,AAAIR,AAAEO,AAAKC;AAFhK,AAGE,AAAIP;AACF,AAACQ,AAAoCR;;AACrC,AAAMS,AAAuB,AAACC,AAAIjC,AAAiByB;AAC7CS,AAAuB,AAAKvB,AAAQH;AAAb,AACE,AAAM,AAAC2B,AAAK,AAAKC;AAAL,AAAW,AAACA,AAAAA,AAAAA,AAAKzB,AAAAA;AACjBqB;AADZ,AAEE,AAACK,AAAkB,AAACC,AAAKZ,AAAYf;;AAFvC;;;AAF/B,AAKE,AAAC4B,AAAiCf,AAASU;;;AAX3E,AAYE,AAAKM;AAAL,AACE,AACE,AAACZ,AAAKY;AAAK,AAACzB,AAAkByB;;AADhC,AAEE,AAACC,AAAYD;AAAK,AAACE,AAAM,AAACT,AAAIlB,AAAkByB;;AAFlD,AAGQ,AAAA,AAAA,AAACG,AAAsFH","names":["day8.re-frame.forward-events-fx/as-callback-pred","callback-pred","cljs.core/fn?","cljs.core/Keyword","p__94670","vec__94674","cljs.core.nth","event-id","_","cljs.core._EQ_","cljs.core/coll?","event-v","cljs.core.ex_info","cljs.core.pr_str","re-frame.core/reg-fx","process-one-entry","p__94683","map__94684","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","m","unregister","register","events","dispatch-to","js/Error","cljs.core/map?","cljs.core/keys","cljs.core/set","re-frame.core/remove-post-event-callback","events-preds","cljs.core.map","post-event-callback-fn","cljs.core/some","pred","re-frame.core/dispatch","cljs.core.conj","re_frame.core.add_post_event_callback","val","cljs.core/sequential?","cljs.core.doall","re_frame.core.console"],"sourcesContent":["(ns day8.re-frame.forward-events-fx\n  (:require [re-frame.core :as re-frame]))\n\n\n(defn as-callback-pred\n  \"Looks at the required-events items and returns a predicate which\n  will either\n  - match only the event-keyword if a keyword is supplied\n  - match the entire event vector if a collection is supplied\n  - returns a callback-pred if it is a fn\"\n  [callback-pred]\n  (when callback-pred\n    (cond (fn? callback-pred) callback-pred\n          (keyword? callback-pred) (fn [[event-id _]]\n                                     (= callback-pred event-id))\n          (coll? callback-pred) (fn [event-v]\n                                  (= callback-pred event-v))\n          :else (throw\n                  (ex-info (str (pr-str callback-pred)\n                             \" isn't an event predicate\")\n                    {:callback-pred callback-pred})))))\n\n\n(re-frame/reg-fx\n  :forward-events\n  (let [process-one-entry (fn [{:as m :keys [unregister register events dispatch-to]}]\n                            (let [_ (assert (map? m) (str \"re-frame: effects handler for :forward-events expected a map or a list of maps. Got: \" m))\n                                  _ (assert (or (= #{:unregister} (-> m keys set))\n                                                (= #{:register :events :dispatch-to} (-> m keys set))) (str \"re-frame: effects handler for :forward-events given wrong map keys\" (-> m keys set)))]\n                              (if unregister\n                                (re-frame/remove-post-event-callback unregister)\n                                (let [events-preds           (map as-callback-pred events)\n                                      post-event-callback-fn (fn [event-v _]\n                                                               (when (some (fn [pred] (pred event-v))\n                                                                           events-preds)\n                                                                 (re-frame/dispatch (conj dispatch-to event-v))))]\n                                  (re-frame/add-post-event-callback register post-event-callback-fn)))))]\n    (fn [val]\n      (cond\n        (map? val) (process-one-entry val)\n        (sequential? val) (doall (map process-one-entry val))\n        :else (re-frame/console :error \":forward-events expected a map or a list of maps, but got: \" val)))))\n"]}