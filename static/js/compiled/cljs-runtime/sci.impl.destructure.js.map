{"version":3,"sources":["sci/impl/destructure.cljc"],"mappings":"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","names":["sci.impl.destructure/destructure*","bindings","bents","cljs.core.partition","pb","bvec","b","v","pvec","val","gvec","sci.impl.utils.gensym_STAR_","gseq","gfirst","has-rest","cljs.core/some","ret","cljs.core.conj","sci.impl.utils/mark-eval-call","cljs.core/List","cljs.core/seq","n","bs","seen-rest?","firstb","cljs.core/first","cljs.core._EQ_","cljs.core/second","cljs.core/nnext","js/Error","cljs.core.sequence","cljs.core.concat","cljs.core/next","cljs.core/nth","pmap","gmap","defaults","cljs.core/seq?","cljs.core/apply","cljs.core/hash-map","bes","transforms","cljs.core.reduce","mk","cljs.core/Keyword","mkns","cljs.core/namespace","mkn","cljs.core/name","p1__97273#","cljs.core.assoc","cljs.core.keyword","or__4126__auto__","p1__97274#","cljs.core.symbol","cljs.core/str","cljs.core/keys","entry","p1__97279#","p2__97280#","fexpr__97325","cljs.core/val","cljs.core.dissoc","cljs.core/key","fexpr__97326","bb","bk","local","cljs.core/PROTOCOL_SENTINEL","cljs.core/with-meta","cljs.core/meta","cljs.core/not","bv","temp__5733__auto__","default","cljs.core.get","cljs.core/get","cljs.core/Symbol","cljs.core/vector?","cljs.core/map?","process-entry","cljs.core/every?","cljs.core/symbol?","cljs.core.map","kwbs","p1__97281#","cljs.core.filter","cljs.core/ffirst","sci.impl.destructure/destructure"],"sourcesContent":["(ns sci.impl.destructure\n  \"Destructure function, adapted from Clojure and ClojureScript.\"\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure])\n  (:require [sci.impl.utils :refer [gensym* mark-eval-call]]))\n\n(defn destructure* [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n             (let [pvec\n                   (fn [bvec b val]\n                     (let [gvec (gensym* \"vec__\")\n                           gseq (gensym* \"seq__\")\n                           gfirst (gensym* \"first__\")\n                           has-rest (some #{'&} b)]\n                       (loop [ret (let [ret (conj bvec gvec val)]\n                                    (if has-rest\n                                      (conj ret gseq (mark-eval-call (list seq gvec)))\n                                      ret))\n                              n 0\n                              bs b\n                              seen-rest? false]\n                         (if (seq bs)\n                           (let [firstb (first bs)]\n                             (cond\n                               (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                    n\n                                                    (nnext bs)\n                                                    true)\n                               (= firstb :as) (pb ret (second bs) gvec)\n                               :else (if seen-rest?\n                                       (throw #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                 :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                       (recur (pb (if has-rest\n                                                    (conj ret\n                                                          gfirst (mark-eval-call `(~first ~gseq))\n                                                          gseq (mark-eval-call `(~next ~gseq)))\n                                                    ret)\n                                                  firstb\n                                                  (if has-rest\n                                                    gfirst\n                                                    (mark-eval-call (list nth gvec n nil))))\n                                              (inc n)\n                                              (next bs)\n                                              seen-rest?))))\n                           ret))))\n                   pmap\n                   (fn [bvec b v]\n                     (let [gmap (gensym* \"map__\")\n                           defaults (:or b)]\n                       (loop [ret (-> bvec (conj gmap) (conj v)\n                                      (conj gmap) (conj (mark-eval-call\n                                                         `(if ~(mark-eval-call `(~seq? ~gmap))\n                                                            ~(mark-eval-call `(~apply ~hash-map ~gmap))\n                                                            ~gmap)))\n                                      ((fn [ret]\n                                         (if (:as b)\n                                           (conj ret (:as b) gmap)\n                                           ret))))\n                              bes (let [transforms\n                                        (reduce\n                                         (fn [transforms mk]\n                                           (if (keyword? mk)\n                                             (let [mkns (namespace mk)\n                                                   mkn (name mk)]\n                                               (cond (= mkn \"keys\")\n                                                     (assoc transforms mk\n                                                            #(keyword (or mkns (namespace %))\n                                                                      (name %)))\n                                                     (= mkn \"syms\")\n                                                     (assoc transforms mk\n                                                            #(symbol (or mkns\n                                                                         (namespace %))\n                                                                     (name %)))\n                                                     (= mkn \"strs\") (assoc transforms mk str)\n                                                     :else transforms))\n                                             transforms))\n                                         {}\n                                         (keys b))]\n                                    (reduce\n                                     (fn [bes entry]\n                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     transforms))]\n                         (if (seq bes)\n                           (let [bb (key (first bes))\n                                 bk (val (first bes))\n                                 local (if #?(:clj  (instance? clojure.lang.Named bb)\n                                              :cljs (implements? INamed bb))\n                                         (with-meta (symbol nil (name bb)) (meta bb))\n                                         bb)\n                                 ;; if bk has metadata (:line, :column, etc)\n                                 ;; then it's a binding that needs eval\n                                 bk (if-not (meta bk)\n                                      (list 'quote bk)\n                                      bk)\n                                 bv (if-let [default (get defaults local)]\n                                      (mark-eval-call (list get gmap bk default))\n                                      (mark-eval-call (list get gmap bk)))]\n                             (recur\n                              (if (or (keyword? bb) (symbol? bb)) ;(ident? bb)\n                                (-> ret (conj local bv))\n                                (pb ret bb bv))\n                              (next bes)))\n                           ret))))]\n               (cond\n                 (symbol? b) (-> bvec (conj (if (namespace b)\n                                              (symbol (name b)) b)) (conj v))\n                 (keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                 (vector? b) (pvec bvec b v)\n                 (map? b) (pmap bvec b v)\n                 :else (throw\n                        #?(:clj (new Exception (str \"Unsupported binding form: \" b))\n                           :cljs (new js/Error (str \"Unsupported binding form: \" b)))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (if-let [kwbs (seq (filter #(keyword? (first %)) bents))]\n        (throw\n         #?(:clj (new Exception (str \"Unsupported binding key: \" (ffirst kwbs)))\n            :cljs (new js/Error (str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))\n\n(defn destructure [b]\n  (destructure* b))\n"]}