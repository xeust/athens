{"version":3,"sources":["sci/core.cljc"],"mappings":"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","names":["var_args","G__99188","sci.core/new-var","js/Error","name","G__99195","sci.core.new_var","sci.impl.vars/unbind","init-val","cljs.core/meta","meta","sci.impl.vars/SciVar","G__99200","sci.core/new-dynamic-var","G__99201","sci.core.new_dynamic_var","cljs.core.assoc","G__99203","sci.core/new-macro-var","cljs.core.vary_meta","cljs.core/assoc","sci.core/in","sci.impl.io/in","sci.core/out","sci.impl.io/out","sci.core/err","sci.impl.io/err","sci.core/ns","sci.impl.vars/current-ns","sci.core/file","sci.impl.vars/current-file","sci.core/print-length","sci.impl.io/print-length","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.core/alter-var-root","seq99222","G__99223","cljs.core/first","cljs.core/next","G__99224","self__4723__auto__","v","f","args","cljs.core.apply","sci.impl.vars/alter-var-root","G__99228","sci.core/eval-string","s","sci.core.eval_string","opts","sci.impl.interpreter.eval_string","sci.core/init","sci.impl.opts/init","sci.core/eval-string*","ctx","sci.impl.interpreter/eval-string*","G__99230","sci.core/create-ns","sym","sci.core.create_ns","sci.impl.vars/->SciNamespace"],"sourcesContent":["(ns sci.core\n  (:refer-clojure :exclude [with-bindings with-in-str with-out-str\n                            with-redefs binding future pmap alter-var-root\n                            ns create-ns])\n  (:require\n   [sci.impl.interpreter :as i]\n   [sci.impl.io :as sio]\n   [sci.impl.macros :as macros]\n   [sci.impl.opts :as opts]\n   [sci.impl.vars :as vars])\n  #?(:cljs (:require-macros\n            [sci.core :refer [with-bindings with-out-str copy-var]])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn new-var\n  \"Alpha! Returns a new sci var. API subject to change.\"\n  ([name] (doto (new-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name meta)))\n\n(defn new-dynamic-var\n  \"Alpha! Same as new-var but adds :dynamic true to meta. API subject to\n  change.\"\n  ([name] (doto (new-dynamic-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-dynamic-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name (assoc meta :dynamic true))))\n\n(defn new-macro-var\n  \"Alpha! Same as new-var but adds :macro true to meta as well\n  as :sci/macro true to meta of the fn itself. API subject to change.\"\n  ([name init-val] (new-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar.\n                         (vary-meta init-val\n                                    assoc :sci/macro true)\n                         name (assoc meta :macro true))))\n\n(defmacro copy-var\n  \"Copies contents from var `sym` to a new sci var. The value `ns` is an\n  object created with `sci.core/create-ns`.\"\n  ([sym ns]\n   `(let [ns# ~ns\n          var# (var ~sym)\n          val# (deref var#)\n          m# (-> var# meta)\n          ns-name# (vars/getName ns#)\n          name# (:name m#)\n          name-sym# (symbol (str ns-name#) (str name#))\n          new-m# {:doc (:doc m#)\n                  :name name#\n                  :arglists (:arglists m#)\n                  :ns ns#}]\n      (cond (:dynamic m#)\n            (new-dynamic-var name# val# new-m#)\n            (:macro m#)\n            (new-macro-var name# val# new-m#)\n            :else (new-var name# val# new-m#)))))\n\n(macros/deftime\n  (defmacro with-bindings\n    \"Macro for binding sci vars. Must be called with map of sci dynamic\n  vars to values. Used in babashka.\"\n    [bindings-map & body]\n    `(let [bm# ~bindings-map]\n       (assert (map? bm#))\n       (vars/push-thread-bindings bm#) ;; important: outside try\n       (try\n         (do ~@body)\n         (finally (vars/pop-thread-bindings)))))\n\n  (defmacro binding\n    \"Macro for binding sci vars. Must be called with a vector of sci\n  dynamic vars to values.\"\n    [bindings & body]\n    (assert (vector? bindings))\n    `(with-bindings ~(apply hash-map bindings)\n       (do ~@body))))\n\n(def in \"Sci var that represents sci's `clojure.core/*in*`\" sio/in)\n(def out \"Sci var that represents sci's `clojure.core/*out*`\" sio/out)\n(def err \"Sci var that represents sci's `clojure.core/*err*`\" sio/err)\n(def ns \"Sci var that represents sci's `clojure.core/*ns*`\" vars/current-ns)\n(def file \"Sci var that represents sci's `clojure.core/*file*`\" vars/current-file)\n(def print-length \"Sci var that represents sci's `clojure.core/*print-length*`\" sio/print-length)\n\n(macros/deftime\n  (defmacro with-in-str\n    \"Evaluates body in a context in which sci's *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n    [s & body]\n    `(let [in# (-> (java.io.StringReader. ~s)\n                   (clojure.lang.LineNumberingPushbackReader.))]\n       (with-bindings {in in#}\n         (do ~@body)))))\n\n(macros/deftime\n  (defmacro with-out-str\n    \"Evaluates exprs in a context in which sci's *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n    [& body]\n    `(let [out# (macros/? :clj (java.io.StringWriter.)\n                          :cljs (goog.string/StringBuffer.))]\n       (with-bindings {out out#}\n         (do ~@body)\n         (str out#)))))\n\n(macros/deftime\n  (defmacro future\n    \"Like clojure.core/future but also conveys sci bindings to the thread.\"\n    [& body]\n    `(let [f# (-> (fn [] ~@body)\n                  (vars/binding-conveyor-fn))]\n       (future-call f#))))\n\n#?(:clj (defn pmap\n          \"Like clojure.core/pmap but also conveys sci bindings to the threads.\"\n          ([f coll]\n           (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n                 rets (map #(future (f %)) coll)\n                 step (fn step [[x & xs :as vs] fs]\n                        (lazy-seq\n                         (if-let [s (seq fs)]\n                           (cons (deref x) (step xs (rest s)))\n                           (map deref vs))))]\n             (step rets (drop n rets))))\n          ([f coll & colls]\n           (let [step (fn step [cs]\n                        (lazy-seq\n                         (let [ss (map seq cs)]\n                           (when (every? identity ss)\n                             (cons (map first ss) (step (map rest ss)))))))]\n             (pmap #(apply f %) (step (cons coll colls)))))))\n\n(defn alter-var-root\n  \"Atomically alters the root binding of sci var v by applying f to its\n  current value plus any args.\"\n  [v f & args]\n  (apply vars/alter-var-root v f args))\n\n(defn eval-string\n  \"Evaluates string `s` as one or multiple Clojure expressions using the Small Clojure Interpreter.\n\n  The map `opts` may contain the following:\n\n  - `:bindings`: a map of symbols to values, e.g.: `{'x 1}`. The\n  symbols will acts as names bound to the corresponding values in the\n  expressions.\n\n  - `:namespaces`: a map of symbols to namespaces, where a namespace\n  is a map with symbols to values, e.g.: `{'foo.bar {'x 1}}`. These\n  namespaces can be used with `require`.\n\n  - `:allow`: a seqable of allowed symbols. All symbols, even those\n  brought in via `:bindings` or `:namespaces` have to be explicitly\n  enumerated.\n\n  - `:deny`: a seqable of disallowed symbols, e.g.: `[loop quote\n  recur]`.\n\n  - `:realize-max`: integer; when provided, program may realize a\n  maximum number of elements from sequences, e.g. `(vec (range))` will\n  throw for any number. This also applies to sequences returned from\n  the expression to the caller.\n\n  - `:preset`: a pretermined set of options. Currently only\n  `:termination-safe` is supported, which will set `:realize-max` to\n  `100` and disallows the symbols `loop`, `recur` and `trampoline`.\n\n  - `:features`: when provided a non-empty set of keywords, sci will process reader conditionals using these features (e.g. #{:bb}).\n\n  - `:env`: an atom with a map in which state from the\n  evaluation (defined namespaced and vars) will be persisted for\n  re-use over multiple calls.\n  \"\n  ([s] (eval-string s nil))\n  ([s opts]\n   (i/eval-string s opts)))\n\n(defn init\n  \"Creates an initial sci context from given options `opts`. The context\n  can be used with `eval-string*`. See `eval-string` for available\n  options. The internal organization of the context is implementation\n  detail and may change in the future.\"\n  [opts]\n  (opts/init opts))\n\n(defn eval-string*\n  \"Evaluates string `s` in the context of `ctx` (as produced with\n  `init`).\"\n  [ctx s]\n  (sci.impl.interpreter/eval-string* ctx s))\n\n(defn create-ns\n  \"Creates namespace object. Can be used in var metadata.\"\n  ([sym] (create-ns sym nil))\n  ([sym meta]\n   (vars/->SciNamespace sym meta)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"(inc x)\" {:bindings {'x 2}})\n  )\n"]}