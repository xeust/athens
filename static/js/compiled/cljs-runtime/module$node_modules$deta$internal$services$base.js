shadow$provide.module$node_modules$deta$internal$services$base=function(global,require,module,exports){global=require("module$node_modules$deta$internal$services$base_service");let isObject=i=>"[object Object]"===Object.prototype.toString.call(i);class Trim{}class Base extends global{constructor(deta,tableName){super(deta);this.getTableName=()=>tableName;this.util={trim:()=>new Trim}}get tableName(){return this.getTableName()}async get(key){if("string"!==typeof key)throw new TypeError("Key must be a string");
const {status,response}=await this.request(`/${this.tableName}/items/${key}`);return 404===status?null:response}async put(item,key){item=isObject(item)?item:{value:item};key&&(item.key=key);const {status,response}=await this.request(`/${this.tableName}/items`,{items:[item]},"PUT");return response&&207===status?response.processed.items[0]:null}async putMany(items){if(!(items instanceof Array))throw new TypeError("Items must be an array");if(25<=items.length)throw Error("We can't put more than 25 items at a time");
const _items=[];items.map(item=>{isObject(item)?_items.push(item):_items.push({value:item})});({response:items}=await this.request(`/${this.tableName}/items`,{items:_items},"PUT"));return items}async delete(key){if("string"!==typeof key)throw new TypeError("Key must be a string");await this.request(`/${this.tableName}/items/${key}`,{},"DELETE");return null}async insert(item,key){item=isObject(item)?item:{value:item};key&&(item.key=key);const {status,response}=await this.request(`/${this.tableName}/items`,
{item},"POST");if(201===status)return response;if(409==status)throw Error(`Item with key ${key} already exists`);}async *fetch(query=[],pages=10,buffer){if(!(0>=pages)){query=Array.isArray(query)?query:[query];var _last,_count=0;do{const {status,response}=await this.request(`/${this.tableName}/query`,{query,limit:buffer,last:_last},"POST"),{paging,items}=response;({last:_last}=paging);yield items;var _status=status;_count+=1}while(200===_status&&_last&&pages>_count)}}async update(updates,key$jscomp$0){if("string"!==
typeof key$jscomp$0)throw new TypeError("Key must be a string");if(!isObject(updates))throw new TypeError("Updates must be a JSON object");const payload={set:{},delete:[]};for(let [key,value]of Object.entries(updates))value instanceof Trim?payload.delete.push(key):payload.set[key]=value;const {status,response}=await this.request(`/${this.tableName}/items/${key$jscomp$0}`,payload,"PATCH");if(200==status)return null;if(404==status)throw Error(`Key '${key$jscomp$0}' not found`);throw Error(response.errors[0]);
}}module.exports=Base}
//# sourceMappingURL=module$node_modules$deta$internal$services$base.js.map
