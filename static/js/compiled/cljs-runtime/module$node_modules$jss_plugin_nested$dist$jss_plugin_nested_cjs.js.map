{
"version":3,
"file":"module$node_modules$jss_plugin_nested$dist$jss_plugin_nested_cjs.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/jss-plugin-nested/dist/jss-plugin-nested.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$jss_plugin_nested$dist$jss_plugin_nested_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar _extends = _interopDefault(require('@babel/runtime/helpers/extends'));\nvar warning = _interopDefault(require('tiny-warning'));\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n\n      if (rule) {\n        rule = rule;\n        return rule.selector;\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Could not find the referenced rule \\\"\" + key + \"\\\" in \\\"\" + (container.options.meta || container.toString()) + \"\\\".\") : void 0;\n      return key;\n    };\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n\n    });\n\n    delete options.name;\n    return options;\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(refRegExp, replaceRef);\n        container.addRule(selector, style[prop], _extends({}, options, {\n          selector: selector\n        }));\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options) // Flow expects more options but they aren't required\n        // And flow doesn't know this will always be a StyleRule which has the addRule method\n        // $FlowFixMe\n        .addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\n\nexports.default = jssNested;\n\n};"],
"names":["shadow$provide","global","require","module","exports","_interopDefault","ex","Object","defineProperty","value","_extends","warning","separatorRegExp","parentRegExp","refRegExp","default","jssNested","getReplaceRef","container","sheet","match","key","rule","getRule","selector","options","meta","toString","onProcessStyle","style","type","parent","replaceRef","prop","isNested","indexOf","isNestedConditional","styleRule","index","nestingLevel","undefined","name","parentSelectors","split","nestedSelectors","nestedProp","result","i","length","j","nested","replace","addRule"]
}
